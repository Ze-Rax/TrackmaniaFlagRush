// #RequireContext CSmMode
/**
*	CYLINDER HITBOX LIB
*	Based on Cyclinder Hitbox Lib by domino54
*	https://github.com/domino54/title-packs/blob/master/Scripts/Libs/domino54/TrackMania/CylinderHitbox.Script.txt
*	Adjusted for TM2020 by Ze-Rax
*
*	This library allows to create virtual cylinder hitbox for
*	the cars, adjust cylinder diameter and height from player
*	rotation and car model size. Allows to check if hitboxes
*	of two players touch.
*/

#Const Version			"2021-09-07"
#Const ScriptName		"CylinderHitbox.Script.txt"

#Include "AnimLib" as AnimLib
#Include "MathLib" as MathLib

// ---------------------------------- //
// Structs
// ---------------------------------- //
#Struct Struct_Hitbox {
	Vec3 Center;
	Real Diameter;
	Real Height;
}

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_DetectionDistance		8.		///< Computes only if distance is smaller than this value
#Const C_VerticalSizeSub			.25		///< Short cylinder diameter to make it more accurate at car longer side

/// Sizes of visible player car models
#Const C_CarModelSizes [
	"CanyonCar"		=> <4.25, 1.125, 2.>,		// Leftover from TM2
	"StadiumCar"	=> <4., 1., 1.75>,			// Leftover from TM2
	"ValleyCar"		=> <4.25, 1.25, 2.25>,	// Leftover from TM2
	"CarSport"		=> <4., 1., 1.75>
]

declare Boolean markerNeedsInitialized;
declare CUIConfigMarker[] tempMarkers;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //

/** Convert pitch in radians to degress
*
*	@param	_Pitch		The pitch to convert
*
*	@return		Pitch converted to degress
*/
Real Private_GetPitch(Real _Pitch) {
	return MathLib::Abs(_Pitch * 2 / MathLib::PI());
}

// ---------------------------------- //
/** Get cylinder diameter
*
*	@param	_Pitch		Pitch used to compute diameter
*
*	@return		Diameter of cylinder
*/
Real Private_GetCyliDiameter(Real _Pitch) {
	return AnimLib::Ease("EaseInCirc", _Pitch, 1., -1., 1.);
}

// ---------------------------------- //
/** Get cylinder height
*
*	@param	_Pitch		Pitch used to compute height
*
*	@return		Height of cylinder
*/
Real Private_GetCyliHeight(Real _Pitch) {
	return AnimLib::Ease("EaseOutCirc", _Pitch, 0., 1., 1.);
}

// ---------------------------------- //
/** Distance between two points in one dimension
*
*	@param	_Pos1		Pirst point position
*	@param	_Pos2		Second point position
*
*	@return		Distance between points
*/
Real Private_Distance1D(Real _Pos1, Real _Pos2) {
	return MathLib::Sqrt(MathLib::Pow(_Pos2 - _Pos1, 2.));
}

// ---------------------------------- //
/** Distance between two points in two dimensions
*
*	@param	_Pos1		Pirst point position
*	@param	_Pos2		Second point position
*
*	@return		Distance between points
*/
Real Private_Distance2D(Vec3 _Pos1, Vec3 _Pos2) {
	return MathLib::Sqrt(MathLib::Pow(_Pos2.X - _Pos1.X, 2.) + MathLib::Pow(_Pos2.Z - _Pos1.Z, 2.));
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script
*
*	@return		The version number of the script
*/
Text GetScriptVersion() {
	return Version;
}

// ---------------------------------- //
/** Return the name of the script
*
*	@return		The name of the script
*/
Text GetScriptName() {
	return ScriptName;
}

// ---------------------------------- //
/** Check if a player is spawn
*
*	@param	_Player		Player to check spawn status of
*
*	@return		True if player is spawned, else False
*/
Boolean IsSpawned(CSmPlayer _Player) {
	if (_Player == Null) return False;
	if (_Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) return True;
	return False;
}

// ---------------------------------- //
/** Check if hitboxes of two players touch
*
*	@param	_Player1	First point position
*	@param	_Player2	Second point position
*
*	@return		True if cylinders touch
*/
Boolean AreTouching(CSmPlayer _Player1, CSmPlayer _Player2) {
	if (_Player1 == Null || _Player2 == Null) return False;
	if (!IsSpawned(_Player1) || !IsSpawned(_Player2)) return False;
	if (_Player1.Position == <0., 0., 0.> || _Player2.Position == <0., 0., 0.>) return False;
	if (!C_CarModelSizes.existskey(MapPlayerModelName)) return False;
	
	// ---------------------------------- //
	// Check if cars are close enough
	if (MathLib::Distance(_Player1.Position, _Player2.Position) > C_DetectionDistance) return False;
	
	// ---------------------------------- //
	// Set hitbox model properties	
	declare Vec3 FixedPos1Front = _Player1.Position + _Player1.AimDirection * 1.184;
	declare Vec3 FixedPos2Front = _Player2.Position + _Player2.AimDirection * 1.184;	
	declare Vec3 FixedPos1Back = _Player1.Position - _Player1.AimDirection * 0.553;
	declare Vec3 FixedPos2Back = _Player2.Position - _Player2.AimDirection * 0.553;

	declare Real Multiplier = 1.;
	if (UsePvPCollisions) Multiplier = 1.34;
	if (Private_Distance2D(FixedPos1Front, FixedPos2Front) < 2. * Multiplier && MathLib::Abs(FixedPos1Front.Y - FixedPos2Front.Y) < 1. * Multiplier) return True;
	if (Private_Distance2D(FixedPos1Front, FixedPos2Back) < 2.07 * Multiplier && MathLib::Abs(FixedPos1Front.Y - FixedPos2Back.Y) < 1. * Multiplier) return True;
	if (Private_Distance2D(FixedPos1Back, FixedPos2Front) < 2.07 * Multiplier && MathLib::Abs(FixedPos1Back.Y - FixedPos2Front.Y) < 1. * Multiplier) return True;
	if (Private_Distance2D(FixedPos1Back, FixedPos2Back) < 2.14 * Multiplier && MathLib::Abs(FixedPos1Back.Y - FixedPos2Back.Y) < 1. * Multiplier) return True;

	return False;
}

// ---------------------------------- //
/** Get the cylinder hitbox of a Player
*
*	@param	_Player	The player to get the hitbox of
*
*	@return		Hitbox struct of the player
*/
Struct_Hitbox GetHitbox(CSmPlayer _Player) {
	// Check if player is valid
	if (_Player == Null
		|| !IsSpawned(_Player)
		|| _Player.Position == <0., 0., 0.>
		|| !C_CarModelSizes.existskey(MapPlayerModelName)
	) return Struct_Hitbox{Center = <0., 0., 0.>, Diameter = 0., Height = 0.};
	
	declare Real PlayerPitch = Private_GetPitch(_Player.AimPitch);
	
	// Get Center
	declare Vec3 Center = _Player.Position;
	Center.Y += C_CarModelSizes[MapPlayerModelName].Y / 2;
	
	// Get Diameter
	declare Real Diameter = (C_CarModelSizes[MapPlayerModelName].X - C_VerticalSizeSub) * Private_GetCyliDiameter(PlayerPitch);
	if (Diameter < C_CarModelSizes[MapPlayerModelName].Z) Diameter = C_CarModelSizes[MapPlayerModelName].Z;
	
	// Get Height
	declare Real Height = C_CarModelSizes[MapPlayerModelName].X * Private_GetCyliHeight(PlayerPitch);
	if (Height < C_CarModelSizes[MapPlayerModelName].Y) Height = C_CarModelSizes[MapPlayerModelName].Y;
	
	// Return result
	return Struct_Hitbox{Center = Center, Diameter = Diameter, Height = Height};
}


Struct_Hitbox GetSmallHitbox(CSmPlayer _Player) {
	// Check if player is valid
	if (_Player == Null
		|| !IsSpawned(_Player)
		|| _Player.Position == <0., 0., 0.>
		|| !C_CarModelSizes.existskey(MapPlayerModelName)
	) return Struct_Hitbox{Center = <0., 0., 0.>, Diameter = 0., Height = 0.};
	
	declare Real PlayerPitch = Private_GetPitch(_Player.AimPitch);
	
	// Get Center
	declare Vec3 Center = _Player.Position;
	Center.Y += C_CarModelSizes[MapPlayerModelName].Y / 2;
	
	// Get Diameter
	declare Real Diameter = ((C_CarModelSizes[MapPlayerModelName].X * 0.5) - C_VerticalSizeSub) * Private_GetCyliDiameter(PlayerPitch);
	if (Diameter < C_CarModelSizes[MapPlayerModelName].Z) Diameter = C_CarModelSizes[MapPlayerModelName].Z;
	
	// Get Height
	declare Real Height = (C_CarModelSizes[MapPlayerModelName].X * 0.5) * Private_GetCyliHeight(PlayerPitch);
	if (Height < C_CarModelSizes[MapPlayerModelName].Y) Height = C_CarModelSizes[MapPlayerModelName].Y;
	
	// Return result
	return Struct_Hitbox{Center = Center, Diameter = Diameter, Height = Height};
}


Boolean CheckOverlap(Struct_Hitbox Hitbox1, Struct_Hitbox Hitbox2) {
	if (Hitbox1.Diameter <= 0. || Hitbox2.Diameter <= 0. || Hitbox1.Height <= 0. || Hitbox2.Height <= 0.) return False;
	
	// Check X & Z
	if (Private_Distance2D(Hitbox1.Center, Hitbox2.Center) > (Hitbox1.Diameter + Hitbox2.Diameter) / 2) return False;
	// Check Y
	if (Private_Distance1D(Hitbox1.Center.Y, Hitbox2.Center.Y) - (C_VerticalSizeSub * 2) > (Hitbox1.Height + Hitbox2.Height) / 2) return False;
	
	return True;
}

Vec3 GetCarSize(Text ModelName) {
	return C_CarModelSizes.get(ModelName, <0., 0., 0.>);
}