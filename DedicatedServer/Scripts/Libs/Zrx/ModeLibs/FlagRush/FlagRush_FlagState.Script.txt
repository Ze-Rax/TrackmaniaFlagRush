#Include "MathLib" as ML
#Include "Libs/Zrx/ModeLibs/FlagRush/UI/Modules/Markers.Script.txt" as FlagRush_Markers

#Struct K_FlagPass {
	CUser OldCarrier;
	CUser NewCarrier;
	Integer Date;
}

#Struct K_FlagState {
	CMapLandmark Landmark;
	CUser Carrier;
	Vec3 Position;
	Vec3 PrevPosition;
	Vec3 LastSafePosition;
	Integer LastDropDate;
	Integer PickupableDate;
	K_FlagPass LastFlagPass;
}

#Const C_TeleportThreshold 32 // One block
#Const C_FlagCarrierName_Dropped 	"Dropped"
#Const C_FlagCarrierName_Spawn		"Spawn"
#Const C_DropVerticalOffset 0.5


declare K_FlagState G_FlagState;

/**
 * Gets the current flag carrier CSmPlayer.
 * Null player not found.
 */
CSmPlayer GetFlagCarrierPlayer() {
	if(G_FlagState.Carrier == Null) return Null;
	return GetPlayer(G_FlagState.Carrier.Login);
}

/**
 * Gets the current flag state.
 */
K_FlagState Get() {
	return G_FlagState;
}

/**
 * Updates the position of the flag when carried by a player.
 */
 Void Private_UpdatePosition() {
	declare CSmPlayer CarrierPlayer = GetFlagCarrierPlayer();
	if (CarrierPlayer != Null) {
		G_FlagState.PrevPosition = G_FlagState.Position;
		G_FlagState.Position = CarrierPlayer.Position;
		if (CarrierPlayer.WheelsContactCount >= 3) G_FlagState.LastSafePosition = CarrierPlayer.Position;
	}
}

/**
 * Send data about the flag carrier, i.e. name and clan to the UIs via netwrite
 */
 Void Net_SendFlagState() {
	declare CSmPlayer FlagCarrierPlayer = GetFlagCarrierPlayer();

	// Carrier Clan Index (for color)
	declare netwrite Integer Net_FlagRush_FlagCarrierClan for Teams[0];
	if (FlagCarrierPlayer == Null) Net_FlagRush_FlagCarrierClan = 0;
	else Net_FlagRush_FlagCarrierClan = FlagCarrierPlayer.CurrentClan;

	// Carrier name and login
	declare netwrite Text Net_FlagRush_FlagCarrierName for Teams[0];
	declare netwrite Text Net_FlagRush_FlagCarrierLogin for Teams[0];
	Net_FlagRush_FlagCarrierLogin = "";
	if (FlagCarrierPlayer != Null) {
		Net_FlagRush_FlagCarrierName = FlagCarrierPlayer.User.Name;
		Net_FlagRush_FlagCarrierLogin = FlagCarrierPlayer.User.Login;
	}
	else if (G_FlagState.Landmark != Null) Net_FlagRush_FlagCarrierName = C_FlagCarrierName_Spawn;
	else Net_FlagRush_FlagCarrierName = C_FlagCarrierName_Dropped;

	// Flag Position
	declare netwrite Vec3 Net_FlagRush_FlagPosition for Teams[0];
	Net_FlagRush_FlagPosition = G_FlagState.Position;

	// Gauge timing
	declare FlooredGaugeDuration = G_FlagState.PickupableDate - Now;
	if (FlooredGaugeDuration < 0) FlooredGaugeDuration = 0;
	declare netwrite Integer Net_FlagRush_FlagGaugeStartDate for Teams[0];
	Net_FlagRush_FlagGaugeStartDate = Now;
	declare netwrite Integer Net_FlagRush_FlagGaugeDuration for Teams[0];
	Net_FlagRush_FlagGaugeDuration = FlooredGaugeDuration;
}

/**
 * Sets the flag state to be at a landmark.
 * Also updates the position, the marker and unsets the carrier
 */
Void SetAtLandmark(CMapLandmark Landmark, Integer PickupableDate) {
	G_FlagState.Landmark = Landmark;
	G_FlagState.Position = Landmark.Position;
	G_FlagState.Carrier = Null;
	FlagRush_Markers::FlagMarker_SetOnLandmark(Landmark);
	Net_SendFlagState();
}


Void SetAtLandmark(CMapLandmark Landmark) {
	SetAtLandmark(Landmark, -1);
}

/**
 * Sets the flag state to be at a player.
 * Also updates the position, the marker and unsets the landmark.
 */
Void SetAtCarrier(CSmPlayer Carrier, Integer PickupdableDate) {
	G_FlagState.Carrier = Carrier.User;
	G_FlagState.Landmark = Null;
	G_FlagState.Position = Carrier.Position;
	FlagRush_Markers::FlagMarker_SetOnPlayer(Carrier);
	Net_SendFlagState();
}

Void SetAtCarrier(CSmPlayer Carrier) {
	SetAtCarrier(Carrier, -1);
}

/**
 * Sets the flag state to be at a position.
 * Also updates the marker and unsets the landmark and the carrier.
 */
Void SetAtPosition(Vec3 Position) {
	G_FlagState.Position = Position;
	G_FlagState.Carrier = Null;
	G_FlagState.Landmark = Null;
	FlagRush_Markers::FlagMarker_SetOnPosition(Position);
	Net_SendFlagState();
}

Void SetAtPosition(Vec3 Position, Integer PickupableDate) {
	SetAtPosition(Position, -1);
}

Void DropFlag(Boolean SafePosition) {
	assert(G_FlagState.Carrier != Null, "Cannot drop a flag that is not being carried by anyone");
	declare Vec3 DropPosition;
	if(SafePosition) {
		log("here");
		DropPosition = G_FlagState.LastSafePosition;
	} else {
		declare CSmPlayer OldCarrierPlayer = GetFlagCarrierPlayer();
		if (OldCarrierPlayer != Null) DropPosition = OldCarrierPlayer.Position;
		else DropPosition = G_FlagState.Position;
	}
	SetAtPosition(DropPosition + <0., C_DropVerticalOffset, 0.>);
	G_FlagState.LastDropDate = Now;
}

Void DropFlag() {
	DropFlag(False);
}

/**
 * Set the new flag carrier and also tracks the last pass
 */
Void PassFlag(CSmPlayer NewCarrier) {
	assert(G_FlagState.Carrier != Null, "Cannot pass a flag that is not being carried by anyone");
	assert(NewCarrier != GetFlagCarrierPlayer(), "Cannot pass the flag between same player");
	G_FlagState.LastFlagPass = K_FlagPass{OldCarrier = G_FlagState.Carrier, NewCarrier = NewCarrier.User, Date = Now};
	SetAtCarrier(NewCarrier);
}

Boolean IsDropped() {
	return G_FlagState.Carrier == Null && G_FlagState.Landmark == Null;
}

Boolean CheckDisconnect() {
	declare CSmPlayer CarrierPlayer = GetFlagCarrierPlayer();
	return G_FlagState.Carrier != Null && CarrierPlayer == Null;
}

Boolean CheckLag() {
	return G_FlagState.Carrier != Null && ML::Distance(G_FlagState.PrevPosition,G_FlagState.Position) > C_TeleportThreshold;
}

Void Yield() {
	Private_UpdatePosition();
}