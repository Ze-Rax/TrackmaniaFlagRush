// #RequireContext CSmMode

#Include "TextLib" as TL

#Include "Libs/Nadeo/XmlRpc2.Script.txt"							 									as XmlRpc
#Include "Libs/Zrx/ModeLibs/Common/ModeUtils.Script.txt"								as ModeUtils
#Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_FlagState.Script.txt"			as FlagRush_FlagState
#Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Scores.Script.txt"				as FlagRush_Scores

// XMLRPC events
#Const		C_XMLRPC_FlagPass																"FlagRush.Flag.Pass"
#Const		C_XMLRPC_FlagDrop																"FlagRush.Flag.Drop"
#Const		C_XMLRPC_FlagReset															"FlagRush.Flag.Reset"
#Const 		C_XMLRPC_FlagPickup															"FlagRush.Flag.Pickup"
#Const		C_XMLRPC_FlagScored															"FlagRush.Flag.Scored"

#Const		C_XMLRPC_PlayerDeath														"FlagRush.Player.Death"

#Const		C_XMLRPC_MatchStart															"FlagRush.Flow.MatchStart"
#Const		C_XMLRPC_MatchEnd																"FlagRush.Flow.MatchEnd"
#Const		C_XMLRPC_MapStart																"FlagRush.Flow.MapStart"
#Const		C_XMLRPC_MapEnd																	"FlagRush.Flow.MapEnd"
#Const		C_XMLRPC_RoundStart															"FlagRush.Flow.RoundStart"
#Const		C_XMLRPC_RoundEnd																"FlagRush.Flow.RoundEnd"
#Const		C_XMLRPC_Overtime																"FlagRush.Flow.Overtime"
#Const 		C_XMLRPC_WarmUpStart 														"FlagRush.Flow.WarmUpStart"
#Const 		C_XMLRPC_WarmUpEnd 															"FlagRush.Flow.WarmUpEnd"

/////////////
// Structs //
/////////////

/* Components */

#Struct K_Rpc_Team {
	Integer Num;
	Text Name;
}

#Struct K_Rpc_Player {
	Text Login;
	Text Name;
	Integer TeamNum;
	Vec3 Position;
}

#Struct K_Rpc_Landmark {
	Integer LandmarkId;
	Vec3 Position;
}

#Struct K_Rpc_Flag {
	Vec3 Position;
	K_Rpc_Player Carrier;
	K_Rpc_Landmark Spawn;
}

#Struct K_Rpc_PlayerScore {
	K_Rpc_Player Player;
	Integer Points;
	Integer FlagsScored;
	Integer FlagsStolen;
	Integer Assists;
}

#Struct K_Rpc_Map {
	Text Name;
	Text Uid;
	Text AuthorLogin;
	Text AuthorName;
}

/* Events */

#Struct K_Rpc_FlagPass {
	Integer Time;
	K_Rpc_Player OldCarrier;
	K_Rpc_Flag Flag;
}

#Struct K_Rpc_FlagDrop {
	Integer Time;
	K_Rpc_Player OldCarrier;
	K_Rpc_Flag Flag;
}

#Struct K_Rpc_FlagReset {
	Integer Time;
	K_Rpc_Flag Flag;
}

#Struct K_Rpc_FlagPickup {
	Integer Time;
	K_Rpc_Flag Flag;
}

#Struct K_Rpc_FlagScored {
	Integer Time;
	K_Rpc_Player Scorer;
	K_Rpc_Player Assist;
	Integer[] TeamScores;
}

#Struct K_Rpc_PlayerDeath {
	Integer Time;
	K_Rpc_Player Player;
}

#Struct K_Rpc_Flow {
	Integer Time;
	K_Rpc_Map Map;
	Boolean Valid;
	Integer[] TeamScores;
	K_Rpc_PlayerScore[] PlayerScores;
}

///////////////
// Functions //
///////////////

/* Transformation function */

/**
 * Turns a team into an Rpc_Team.
 */
K_Rpc_Team TeamToRpcTeam(CTeam Team) {
	return K_Rpc_Team {
		Num = Teams.keyof(Team) + 1,
		Name = Team.Name
	};
}

/**
 * Turns a player into an Rpc_Player.
 */
K_Rpc_Player PlayerToRpcPlayer(CSmPlayer Player) {
	return K_Rpc_Player{
		Login = Player.User.Login,
		Name = Player.User.Name,
		TeamNum = Player.CurrentClan,
		Position = Player.Position
	};
}

/**
 * Turns a score into an Rpc_Player.
 * Tries to find the respective player first to gather as much data as possible.
 * If no player is found, then position is default <0., 0., 0.>.
 */
K_Rpc_Player ScoreToRpcPlayer(CSmScore Score) {
	declare CSmPlayer Player <=> GetPlayer(Score.User.Login);
	if(Player != Null) {
		return PlayerToRpcPlayer(Player);
	}

	return K_Rpc_Player{
		Login = Score.User.Login,
		Name = Score.User.Login,
		TeamNum = Score.TeamNum
	};
}

/**
 * Turns a user into a Rpc_Player.
 * Tries to find the respective player or score first to gather as much data as possible.
 * If no player is found, then position is default <0., 0., 0.>.
 * If also no score is found, then Team is default 0.
 */
K_Rpc_Player UserToRpcPlayer(CUser User) {
	declare CSmPlayer Player <=> GetPlayer(User.Login);
	if(Player != Null) {
		return PlayerToRpcPlayer(Player);
	}

	declare CSmScore Score <=> ModeUtils::GetScore(User.Login);
	if(Score != Null) {
		return ScoreToRpcPlayer(Score);
	}

	return K_Rpc_Player{
		Login = User.Login,
		Name = User.Name
	};
}

/**
 * Turns a landmark into an Rpc_Landmark.
 */
K_Rpc_Landmark LandmarkToRpcLandmark(CMapLandmark Landmark) {
	return K_Rpc_Landmark {
		LandmarkId = TL::ToInteger(TL::Replace("" ^ Landmark.Id, "#", "")),
		Position = Landmark.Position
	};
}

/**
 * Turns a FlagState into an Rpc_Flag(State).
 */
K_Rpc_Flag FlagStateToRpcFlag(FlagRush_FlagState::K_FlagState FlagState) {
	declare K_Rpc_Player Carrier;
	if(FlagState.Carrier != Null) {
		Carrier = UserToRpcPlayer(FlagState.Carrier);
	}

	declare K_Rpc_Landmark FlagSpawn;
	if(FlagState.Landmark != Null) {
		FlagSpawn = LandmarkToRpcLandmark(FlagState.Landmark);
	}

	return K_Rpc_Flag {
		Position = FlagState.Position,
		Carrier = Carrier,
		Spawn = FlagSpawn
	};
}

/**
 * Reduces a map to an Rpc_Map.
 */
K_Rpc_Map MapToRpcMap(CMap Map) {
	return K_Rpc_Map{
		Name = Map.MapInfo.Name,
		Uid = Map.MapInfo.MapUid,
		AuthorLogin = Map.MapInfo.AuthorLogin,
		AuthorName = Map.MapInfo.AuthorNickName
	};
}

K_Rpc_PlayerScore ScoreToRpcPlayerScore(CSmScore Score, Integer ScoreLevel) {
	declare Integer Points;
	declare Integer FlagsScored;
	declare Integer FlagsStolen;
	declare Integer Assists;

	switch (ScoreLevel) {
		case FlagRush_Scores::C_Level_Match: {
			Points = FlagRush_Scores::GetPlayerMatchPoints(Score);
			FlagsScored = FlagRush_Scores::GetPlayerMatchFlagScores(Score);
			FlagsStolen = FlagRush_Scores::GetPlayerMatchFlagSteals(Score);
			Assists = FlagRush_Scores::GetPlayerMatchFlagScoreAssists(Score);
		}
		case FlagRush_Scores::C_Level_Map: {
			Points = FlagRush_Scores::GetPlayerMapPoints(Score);
			FlagsScored = FlagRush_Scores::GetPlayerMapFlagScores(Score);
			FlagsStolen = FlagRush_Scores::GetPlayerMapFlagSteals(Score);
			Assists = FlagRush_Scores::GetPlayerMapFlagScoreAssists(Score);
		}
		case FlagRush_Scores::C_Level_Round: {
			Points = FlagRush_Scores::GetPlayerRoundPoints(Score);
			FlagsScored = FlagRush_Scores::GetPlayerRoundFlagScores(Score);
			FlagsStolen = FlagRush_Scores::GetPlayerRoundFlagSteals(Score);
			Assists = FlagRush_Scores::GetPlayerRoundFlagScoreAssists(Score);
		}
	}

	return K_Rpc_PlayerScore{
		Player = ScoreToRpcPlayer(Score),
		Points = Points,
		FlagsScored = FlagsScored,
		FlagsStolen = FlagsStolen,
		Assists = Assists
	};
}

K_Rpc_PlayerScore[] ScoresToRpcPlayerScores(Integer ScoreLevel) {
	declare K_Rpc_PlayerScore[] Rpc_Scores;
	foreach (Score in Scores) {
		Rpc_Scores.add(ScoreToRpcPlayerScore(Score, ScoreLevel));
	}
	return Rpc_Scores;
}

Integer[] GetTeamScores(Integer ScoreLevel) {
	switch (ScoreLevel) {
		case FlagRush_Scores::C_Level_Match: {
			return [FlagRush_Scores::GetClanMatchPoints(1), FlagRush_Scores::GetClanMatchPoints(2)];
		}
		case FlagRush_Scores::C_Level_Map: {
			return [FlagRush_Scores::GetClanMapPoints(1), FlagRush_Scores::GetClanMapPoints(2)];
		}
		case FlagRush_Scores::C_Level_Round: {
			return [FlagRush_Scores::GetClanRoundPoints(1), FlagRush_Scores::GetClanRoundPoints(2)];
		}
	}
	return [];
}

K_Rpc_Flow CurrentFlowState(Integer ScoreLevel, Boolean Valid) {
	declare K_Rpc_Map Rpc_Map;
	if (Map != Null) {
		Rpc_Map = MapToRpcMap(Map);
	}

	return K_Rpc_Flow{
		Time = Now,
		Map = Rpc_Map,
		Valid = Valid,
		TeamScores = GetTeamScores(ScoreLevel),
		PlayerScores = ScoresToRpcPlayerScores(ScoreLevel)
	};
}

K_Rpc_Flag CurrentFlagState() {
	return FlagStateToRpcFlag(FlagRush_FlagState::Get());
}

/* Flag-Events */

Void Send_FlagReset() {
	declare K_Rpc_FlagReset Data = K_Rpc_FlagReset{
		Time = Now,
		Flag = CurrentFlagState()
	};
	XmlRpc::SendCallback(C_XMLRPC_FlagReset, Data.tojson());
}

Void Send_FlagPickup() {
	declare K_Rpc_FlagPickup Data = K_Rpc_FlagPickup{
		Time = Now,
		Flag = CurrentFlagState()
	};
	XmlRpc::SendCallback(C_XMLRPC_FlagPickup, Data.tojson());
}

Void Send_FlagDrop(CUser OldCarrierNullable) {
	declare K_Rpc_Player OldCarrier;
	if(OldCarrierNullable != Null) {
		OldCarrier = UserToRpcPlayer(OldCarrierNullable);
	}

	declare K_Rpc_FlagDrop Data = K_Rpc_FlagDrop{
		Time = Now,
		Flag = CurrentFlagState(),
		OldCarrier = OldCarrier
	};
	XmlRpc::SendCallback(C_XMLRPC_FlagDrop, Data.tojson());
}

Void Send_FlagPass(CSmPlayer OldCarrier) {
	declare K_Rpc_FlagPass Data = K_Rpc_FlagPass{
		Time = Now,
		OldCarrier = PlayerToRpcPlayer(OldCarrier),
		Flag = CurrentFlagState()
	};
	XmlRpc::SendCallback(C_XMLRPC_FlagPass, Data.tojson());
}

Void Send_FlagScored(CSmPlayer _Scorer, CUser _AssistNullable) {
	declare K_Rpc_Player Scorer = PlayerToRpcPlayer(_Scorer);
	declare K_Rpc_Player Assist;
	if(_AssistNullable != Null) {
		Assist = UserToRpcPlayer(_AssistNullable);
	}

	declare K_Rpc_FlagScored Data = K_Rpc_FlagScored{
		Time = Now,
		Scorer = Scorer,
		Assist = Assist,
		TeamScores = GetTeamScores(FlagRush_Scores::C_Level_Round)
	};
	XmlRpc::SendCallback(C_XMLRPC_FlagScored, Data.tojson());
}

/* Player-Events */

Void Send_PlayerDeath(CSmPlayer Player) {
	declare K_Rpc_PlayerDeath Data = K_Rpc_PlayerDeath{
		Time = Now,
		Player = PlayerToRpcPlayer(Player)
	};
	XmlRpc::SendCallback(C_XMLRPC_PlayerDeath, Data.tojson());
}

/* Flow-Events */

Void Send_MatchStart() {
	declare K_Rpc_Flow Data = CurrentFlowState(FlagRush_Scores::C_Level_Match, True);
	XmlRpc::SendCallback(C_XMLRPC_MatchStart, Data.tojson());
}

Void Send_MatchEnd(Boolean Valid) {
	declare K_Rpc_Flow Data = CurrentFlowState(FlagRush_Scores::C_Level_Match, Valid);
	XmlRpc::SendCallback(C_XMLRPC_MatchEnd, Data.tojson());
}

Void Send_MapStart() {
	declare K_Rpc_Flow Data = CurrentFlowState(FlagRush_Scores::C_Level_Match, True);
	XmlRpc::SendCallback(C_XMLRPC_MapStart, Data.tojson());
}

Void Send_MapEnd(Boolean Valid) {
	declare K_Rpc_Flow Data = CurrentFlowState(FlagRush_Scores::C_Level_Map, Valid);
	XmlRpc::SendCallback(C_XMLRPC_MapEnd, Data.tojson());
}

Void Send_RoundStart() {
	declare K_Rpc_Flow Data = CurrentFlowState(FlagRush_Scores::C_Level_Map, True);
	XmlRpc::SendCallback(C_XMLRPC_RoundStart, Data.tojson());
}

Void Send_RoundEnd(Boolean Valid) {
	declare K_Rpc_Flow Data = CurrentFlowState(FlagRush_Scores::C_Level_Round, Valid);
	XmlRpc::SendCallback(C_XMLRPC_RoundEnd, Data.tojson());
}

Void Send_WarmUpStart() {
	declare K_Rpc_Flow Data = CurrentFlowState(-1, True);
	XmlRpc::SendCallback(C_XMLRPC_WarmUpStart, Data.tojson());
}

Void Send_WarmUpEnd() {
	declare K_Rpc_Flow Data = CurrentFlowState(-1, True);
	XmlRpc::SendCallback(C_XMLRPC_WarmUpEnd, Data.tojson());
}

Void Send_OverTime() {
	declare K_Rpc_Flow Data = CurrentFlowState(FlagRush_Scores::C_Level_Round, True);
	XmlRpc::SendCallback(C_XMLRPC_Overtime, Data.tojson());
}

Void RegisterCallbacks() {
	XmlRpc::RegisterCallback(C_XMLRPC_FlagReset, "Called when flag is reset");
	XmlRpc::RegisterCallback(C_XMLRPC_FlagPickup, "Called when a player picks up the flag");
	XmlRpc::RegisterCallback(C_XMLRPC_FlagDrop, 	"Called when flag is dropped");
	XmlRpc::RegisterCallback(C_XMLRPC_FlagPass, "Called when flag is passed or stolen");
	XmlRpc::RegisterCallback(C_XMLRPC_FlagScored, "Called when flag is scored");

	XmlRpc::RegisterCallback(C_XMLRPC_PlayerDeath, "Called when player gets out of bounds");

	XmlRpc::RegisterCallback(C_XMLRPC_MatchStart, "Called when a match starts");
	XmlRpc::RegisterCallback(C_XMLRPC_MatchEnd, "Called when a match ends");
	XmlRpc::RegisterCallback(C_XMLRPC_MapStart, "Called when a map starts");
	XmlRpc::RegisterCallback(C_XMLRPC_MapEnd, "Called when a map ends");
	XmlRpc::RegisterCallback(C_XMLRPC_RoundStart, "Called when a round starts");
	XmlRpc::RegisterCallback(C_XMLRPC_RoundEnd, "Called when a round ends");
	XmlRpc::RegisterCallback(C_XMLRPC_WarmUpStart, "Called when warmup starts");
	XmlRpc::RegisterCallback(C_XMLRPC_WarmUpEnd, "Called when warmup ends");
	XmlRpc::RegisterCallback(C_XMLRPC_Overtime, "Called when overtime starts");
}

Void UnregisterCallbacks() {
	XmlRpc::UnregisterCallback(C_XMLRPC_FlagReset);
	XmlRpc::UnregisterCallback(C_XMLRPC_FlagPickup);
	XmlRpc::UnregisterCallback(C_XMLRPC_FlagDrop);
	XmlRpc::UnregisterCallback(C_XMLRPC_FlagPass);
	XmlRpc::UnregisterCallback(C_XMLRPC_FlagScored);

	XmlRpc::UnregisterCallback(C_XMLRPC_PlayerDeath);

	XmlRpc::UnregisterCallback(C_XMLRPC_MatchStart);
	XmlRpc::UnregisterCallback(C_XMLRPC_MatchEnd);
	XmlRpc::UnregisterCallback(C_XMLRPC_MapStart);
	XmlRpc::UnregisterCallback(C_XMLRPC_MapEnd);
	XmlRpc::UnregisterCallback(C_XMLRPC_RoundStart);
	XmlRpc::UnregisterCallback(C_XMLRPC_RoundEnd);
	XmlRpc::UnregisterCallback(C_XMLRPC_WarmUpStart);
	XmlRpc::UnregisterCallback(C_XMLRPC_WarmUpEnd);
	XmlRpc::UnregisterCallback(C_XMLRPC_Overtime);
}

Void Unload() {
	UnregisterCallbacks();
	XmlRpc::Disable();
}

Void Load() {
	XmlRpc::Enable();
	RegisterCallbacks();
}