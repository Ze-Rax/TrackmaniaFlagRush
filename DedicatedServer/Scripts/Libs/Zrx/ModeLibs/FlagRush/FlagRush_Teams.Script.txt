#Include "/Libs/Zrx/ModeLibs/FlagRush/UI/FlagRush_ColorPalette.Script.txt"	as Colors
#Include "/Libs/Rx/ModeLibs/Common/NiceColors.Script.txt"	as NCL
#Include "MathLib" as ML
#Include "TextLib" as TL

#Const	C_DefaultTeamHue						120
#Const	C_DefaultTeamHues						[0 => 240, 1 => 0]

#Struct K_TeamColor {
	Text TeamName;
	Text SkinName;
}

#Const C_TeamColorLut [
	K_TeamColor{ TeamName = "Red", SkinName = "Skins/Models/CarSport/Stadium_Clan_ladybug.zip" },
	K_TeamColor{ TeamName = "Orange", SkinName = "Skins/Models/CarSport/Stadium_Clan_fox.zip" },
	K_TeamColor{ TeamName = "Yellow", SkinName = "Skins/Models/CarSport/Stadium_Clan_bee.zip" },
	K_TeamColor{ TeamName = "Lime", SkinName = "Skins/Models/CarSport/Stadium_Clan_grasshopper.zip" },
	K_TeamColor{ TeamName = "Green", SkinName = "Skins/Models/CarSport/Stadium_Clan_crocodile.zip" },
	K_TeamColor{ TeamName = "Teal", SkinName = "Skins/Models/CarSport/Stadium_Clan_peafowl.zip" },
	K_TeamColor{ TeamName = "Cyan", SkinName = "Skins/Models/CarSport/Stadium_Clan_rabbit.zip" },
	K_TeamColor{ TeamName = "Azure", SkinName = "Skins/Models/CarSport/Stadium_Clan_polar_bear.zip" },
	K_TeamColor{ TeamName = "Blue", SkinName = "Skins/Models/CarSport/Stadium_Clan_dolphin.zip" },
	K_TeamColor{ TeamName = "Purple", SkinName = "Skins/Models/CarSport/Stadium_Clan_butterfly.zip" },
	K_TeamColor{ TeamName = "Magenta", SkinName = "Skins/Models/CarSport/Stadium_Clan_octopus.zip" },
	K_TeamColor{ TeamName = "Rose", SkinName = "Skins/Models/CarSport/Stadium_Clan_pig.zip" },
	K_TeamColor{ TeamName = "Red", SkinName = "Skins/Models/CarSport/Stadium_Clan_ladybug.zip" }
]

#Struct K_TeamConfig {
	Text ClubTag;
	Text Name;
	Integer Hue;
	Text SkinName;
	Ident ItemId;
}

declare K_TeamConfig[Integer] G_TeamConfigs;
declare Text[Integer] G_TeamNameOverrides;
declare Integer[Integer] G_TeamHueOverrides;
declare Ident[Integer] G_SkinIds;
declare Boolean G_UseClubTags;

Integer Private_GetClosestLutIndex(Integer Hue) {
	declare Integer LutIdx = 0;
	declare Integer Dist = 400;
	for (I, 0, 12) {
		declare Integer H = I * 30;
		if (ML::Abs(Hue - H) < Dist){
			Dist = ML::Abs(Hue - H);
			LutIdx = I;
		}
	}
	return LutIdx;
}

Void SetTeam1NameOverride(Text Name) {
	G_TeamNameOverrides[1] = Name;
}

Void SetTeam2NameOverride(Text Name) {
	G_TeamNameOverrides[2] = Name;
}

Void SetTeam1HueOverride(Integer Hue) {
	G_TeamHueOverrides[1] = Hue;
}

Void SetTeam2HueOverride(Integer Hue) {
	G_TeamHueOverrides[2] = Hue;
}

Void UseClubTags(Boolean UseClubTags) {
	G_UseClubTags = UseClubTags;
}

Void LoadSkins() {
	foreach (Index => TeamColor in C_TeamColorLut) {
		G_SkinIds[Index] = ItemList_AddWithSkin("CarSport", TeamColor.SkinName);
	}
}

Ident GetSkinModelIdForTeam(Integer Clan) {
	if (G_TeamConfigs.existskey(Clan)) {
		return G_TeamConfigs[Clan].ItemId;
	}
	return NullId;
}

Text GetSkinNameForTeam(Integer Clan) {
	if (G_TeamConfigs.existskey(Clan)) {
		return G_TeamConfigs[Clan].SkinName;
	}
	return "";
}

Integer GetDefaultTeamHue(Integer Clan) {
	return C_DefaultTeamHues.get(Clan - 1, C_DefaultTeamHue);
}

Text GetDefaultTeamName(Integer Clan) {
	declare Text Teamname = "???";
	if (G_TeamConfigs.existskey(Clan)) {
		declare Integer Idx = Private_GetClosestLutIndex(G_TeamConfigs[Clan].Hue);
		Teamname = C_TeamColorLut[Idx].TeamName;
	}
	return "Team " ^ Teamname;
}

Void Private_OverrideForcedOrEmptyFields() {
	for(Clan, 1, 2) {
		if(G_TeamHueOverrides.get(Clan, -1) != -1) // Forced
			G_TeamConfigs[Clan].Hue = G_TeamHueOverrides[Clan];
		else if (G_TeamConfigs[Clan].Hue == 0) // Was empty
			G_TeamConfigs[Clan].Hue = GetDefaultTeamHue(Clan);

		if (G_TeamNameOverrides.get(Clan, "") != "") // Forced
			G_TeamConfigs[Clan].Name = G_TeamNameOverrides[Clan];
		else if (G_TeamConfigs[Clan].Name == "") // Was empty
			G_TeamConfigs[Clan].Name = GetDefaultTeamName(Clan);
	}
}

Void Private_SetTeamNamesFromClubTags(){
	for (Clan, 1, 2) {
		declare Boolean ClubTagMissmatch;
		declare Text[] ClubTagsTeam;
		foreach (Player in Players) {
			if (Player.CurrentClan == Clan && !Player.RequestsSpectate) { // Is playing
				if (ClubTagsTeam.count == 0) {
					ClubTagsTeam.add(Player.User.ClubTag);
				} else if (!ClubTagsTeam.exists(Player.User.ClubTag)) {
					ClubTagMissmatch = True;
					break;
				}
			}
		}

		if (!ClubTagMissmatch && ClubTagsTeam.count == 1) {
			G_TeamConfigs[Clan].ClubTag = ClubTagsTeam[0];
			G_TeamConfigs[Clan].Name = TL::StripFormatting(ClubTagsTeam[0]);
		}
	}
}

Void Private_SetTeamHueFromMapType() {
	declare metadata Real[Integer] FlagRush_Meta_TeamHues for Map;
	for (Clan, 1, 2) {
		declare Real TeamHue = FlagRush_Meta_TeamHues.get(Clan, -1.);
		if(TeamHue > 0){
			TeamHue *= 360;
		}
		G_TeamConfigs[Clan].Hue = ML::NearestInteger(TeamHue);
	}
}

Void Private_ApplyToTeams() {
	for (Clan, 1, 2) {
		Teams[Clan - 1].Name = G_TeamConfigs[Clan].Name;

		declare Integer Hue = G_TeamConfigs[Clan].Hue;

		declare Vec3 LightColor = NCL::GetLightColor(Hue*1.);
		declare Vec3 MidColor = NCL::GetMidColor(Hue*1.);
		declare Vec3 DarkColor = NCL::GetDarkColor(Hue*1.);

		Teams[Clan - 1].ColorPrimary = MidColor;
		Teams[Clan - 1].ColorSecondary = MidColor;

		declare netwrite Vec3 Net_FlagRush_LightColor for Teams[Clan - 1];
		Net_FlagRush_LightColor = LightColor;
		declare netwrite Vec3 Net_FlagRush_MidColor for Teams[Clan - 1];
		Net_FlagRush_MidColor = MidColor;
		declare netwrite Vec3 Net_FlagRush_DarkColor for Teams[Clan - 1];
		Net_FlagRush_DarkColor = DarkColor;

		declare Integer LutIdx = Private_GetClosestLutIndex(Hue);
		G_TeamConfigs[Clan].SkinName = C_TeamColorLut[LutIdx].SkinName;
		G_TeamConfigs[Clan].ItemId = G_SkinIds.get(LutIdx, NullId);
		log("""Clan {{{Clan}}}, Config: {{{G_TeamConfigs[Clan]}}}""");
	}
}

Void Init() {
	G_TeamConfigs = [1 => K_TeamConfig{}, 2 => K_TeamConfig{}];
	if (Map != Null) Private_SetTeamHueFromMapType();
	if (G_UseClubTags) Private_SetTeamNamesFromClubTags();
	Private_OverrideForcedOrEmptyFields();
	Private_ApplyToTeams();
}