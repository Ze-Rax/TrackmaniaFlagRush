/**
 * FlagRush
 * Gamemode by Ze-Rax, Reaby, Geekid & Rxelux
 */

#Extends "Libs/Zrx/ModeLibs/BaseModes/FlagRushProgressionBase.Script.txt"

#Const	CompatibleMapTypes						"Trackmania\\FlagRushArena,FlagRushArena"
#Const	Version												"1.3.0-dev"
#Const	ScriptName										"Modes/TrackMania/FlagRush.Script.txt"

// ========= //
// Libraries //
// ========= //

// #region Libraries
// !! Commented out libs are already included in base mode, but added in here for Intellisense.

// General Libs
// #Include "TextLib" as TL
// #Include "MathLib" as ML

// #Include "Libs/Zrx/ModeLibs/Common/EventFeed.Script.txt"										as EventFeed
// #Include "Libs/Zrx/ModeLibs/Common/Commands/ModeCommands.Script.txt"				as ModeCommands
// #Include "Libs/Zrx/ModeLibs/Common/Commands/CommandUtils.Script.txt"				as CommandUtils
// #Include "Libs/Zrx/ModeLibs/Common/ModeUtils.Script.txt"										as ModeUtils
// #Include "Libs/Zrx/ModeLibs/Common/WarmUpReadyUp/WarmUpReadyUp.Script.txt"	as WarmUpReadyUp
#Include "Libs/Rx/ModeLibs/Common/Hitbox.Script.txt"													as Hitbox

// FlagRush Libs
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Common.Script.txt"						as FlagRush_Common
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Map.Script.txt"								as FlagRush_Map
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Scores.Script.txt"						as FlagRush_Scores
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_MatchEvaluation.Script.txt"		as FlagRush_MatchEvaluation
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Teams.Script.txt"							as FlagRush_Teams
#Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_FlagState.Script.txt"						as FlagRush_Flag
#Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Handicaps.Script.txt"						as FlagRush_Handicaps


// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_UI2.Script.txt"								as FlagRush_UI
// #Include "Libs/Zrx/ModeLibs/FlagRush/UI/FlagRush_Messages.Script.txt"				as FlagRush_Messages
// #Include "Libs/Zrx/ModeLibs/FlagRush/UI/Modules/Markers.Script.txt"					as FlagRush_Markers
#Include "Libs/Zrx/ModeLibs/FlagRush/UI/Modules/Flash.Script.txt"							as FlagRush_Flash
// #endregion

// ========= //
// Constants //
// ========= //

// #region Constants
#Const C_AssistTimeThreshold 5000
// #endregion

// ======== //
// Settings //
// ======== //

// #region Settings
#Setting S_UseCrudeExtrapolation						False		as "<hidden>"
#Setting S_TrustClientSimu									True		as "<hidden>"

// Gameplay
#Setting S_UseReversedBases									False 	as "<hidden>" // Switch team bases
#Setting S_RandomizeFlagSpawn								True 		as "<hidden>" // Randomize flag spawn location
#Setting S_FlagInitialSpawnDelaySeconds			0. 			as "<hidden>" // Initial flag spawn delay (seconds)
#Setting S_FlagRespawnDelaySeconds					0. 			as "<hidden>" // Flag respawn delay (seconds)
#Setting S_FlagDropStateDurationSeconds			8. 			as "<hidden>" // Flag drop state duration (seconds)
#Setting S_FlagStealResistDurationSeconds		1. 			as "<hidden>" // Flag steal resistance (seconds)
#Setting S_FlagSameTeamSteal								True		as "<hidden>" // Team flag steal
#Setting S_FlagCarrierFragile								True		as "Flag carrier becomes fragile"
#Setting S_FlagCarrierAcceleration					0.7 		as "Flag carrier acceleration (0.0 - 1.0)"
#Setting S_FlagCarrierControl								1.0 		as "<hidden>" // Flag carrier steering control (0.0 - 1.0)
#Setting S_FlagCarrierAdherence							1.0 		as "<hidden>" // Flag carrier adherence (0.0 - 1.0)
#Setting S_RespawnSpeedLimitKmh							30.			as "<hidden>" // Speed limit for player to respawn
#Setting S_RespawnDelay											4.0 		as "Respawn Delay (seconds) (+1.5s Spawn animation)"
#Setting S_DropFlagPickupPenalty						3.			as "<hidden>" // Flag pickup cooldown after dropping (seconds)
#Setting S_DropFlagOnTeleportDetection			True		as "<hidden>"
#Setting S_UseCollisions										False		as "Use collisions (experimental)"
// #endregion

// ======== //
// Commands //
// ======== //

// #region Commands
// Constants are used for Commands from other sources, like UI Events.
// Constants value has to be the same as the name of the respective command without the Command_ prefix.
// The Parameter for the Command has to be sent with the Event in the Params array.
// In case of Vec2/Vec3/Int2/Int3 commands, X, Y & Z each take a seperate entry in the params array.
#Command	Command_ResetFlag								(Boolean) as		"Reset flag"
#Const		C_Command_ResetFlag															"ResetFlag"
// #endregion

// ============== //
// Plugs / Labels //
// ============== //

***Settings***
***
UsePvPCollisions = S_UseCollisions;
***

***LoadLibraries***
***
ModeCommands::AddQuickCommand(C_Command_ResetFlag, "UICommon64_1", "Flag_light");
***

// ~~~~~~~~~~ Turn ~~~~~~~~~~ //

***StartTurn***
***
declare CMapLandmark FlagSpawn = FlagRush_Map::GetDefaultFlagSpawn();
declare Integer FlagSpawnDate = Now + ML::NearestInteger(S_FlagInitialSpawnDelaySeconds * 1000);
Flag_SetAtLandmark(FlagSpawn, FlagSpawnDate);
***

***EndTurn***
***
Flag_Reset(True);
foreach (Player in Players) {
	UnspawnPlayer(Player);
}
FlagRush_Handicaps::ClearQueue();
***

// ~~~~~~~~~~ PlayLoop ~~~~~~~~~~ //

***PlayLoop***
***
FlagRush_Handicaps::Yield();
FlagRush_Flag::Yield();
// Update Flag
if (FlagRush_Flag::CarrierDisconnected()) DropFlag();
if (S_DropFlagOnTeleportDetection && FlagRush_Flag::CarrierTeleported()) DropFlag_PreviousPosition();
if (FlagRush_Flag::IsDropped()) {
	if (Now > FlagRush_Flag::Get().CurrentStateEndDate) {
		Flag_Reset();
	} else {
		foreach (Player in Players) {
			if (Player_CanPickUpDroppedFlag(Player)) {
				PickUpFlag(Player);
			}
		}
	}
}

// Try pass flag
declare CSmPlayer FlagCarrier = FlagRush_Flag::GetFlagCarrierPlayer();
if (FlagCarrier != Null && Now > FlagRush_Flag::Get().CurrentStateEndDate) {
	declare CSmPlayer FlagReceiver;
	foreach (Player in Players) {
		if (Player == FlagCarrier || !Hitbox::AreColliding(FlagCarrier, Player)) continue;
		declare Boolean IsSameTeam = Player.CurrentClan == FlagCarrier.CurrentClan;
		if (IsSameTeam && (!S_FlagSameTeamSteal || FlagReceiver != Null)) continue; // Opponent flag steal priority
		FlagReceiver = Player;
		if (!IsSameTeam) break; // No need to look further if opponent player was found
	}
	if (FlagReceiver != Null) PassFlag(FlagReceiver);
}

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnPlayerTriggersWaypoint: OnPlayerTriggersWaypoint(Event.Player, Event.Landmark);
		case CSmModeEvent::EType::OnPlayerRequestRespawn: OnPlayerRequestsRespawn(Event.Player);
		case CSmModeEvent::EType::OnCommand: OnGameplayCommand(CommandUtils::FromEvent(Event)); // Commands from Mode (Settings or XmlRpc)
	}
}

foreach(Command in ModeCommands::GetPendingCommands()) OnGameplayCommand(Command); // Commands from ModeCommandsUI

foreach (Player in Players) {
	if (Player_RequestsClanChange(Player)) OnPlayerRequestsClanChange(Player);
	if (Player_IsDead(Player)) OnPlayerDeath(Player);
	if (Player_CanSpawn(Player)) Player_Spawn(Player);

	Player_Net_SendPosition(Player);
}
***

// ~~~~~~~~~~ WarmUp ~~~~~~~~~~ //

***WarmUpLoop***
***
foreach (Player in Players) {
	if (Player_RequestsClanChange(Player) || Player_IsDead(Player)) {
		UnspawnPlayer(Player);
	}

	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
		Player_Initialize(Player);
		declare CMapSpawn Spawn = FlagRush_Map::GetSpawn(Player).PlayerSpawn;
		SpawnPlayer(Player, Player.CurrentClan, 100, Spawn, Now + FlagRush_Common::C_SpawnAnimDuration);
	}

	Player_Net_SendPosition(Player);
}

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			UnspawnPlayer(Event.Player);
		}
		case CSmModeEvent::EType::OnPlayerTriggersWaypoint: {
			if (FlagRush_Map::IsOutOfBoundsTrigger(Event.Landmark)) {
				FlagRush_Messages::PlayerOutOfBounds(Event.Player);
				UnspawnPlayer(Event.Player);
			}
		}
	}
}
***

***EndWarmUp***
***
foreach (Player in Players) {
	UnspawnPlayer(Player);
}
***

// ========= //
// Functions //
// ========= //

// #region Flag
Void Flag_SetAtLandmark(CMapLandmark Landmark, Integer PickupableDate) {
	FlagRush_Flag::SetAtLandmark(Landmark, PickupableDate);
	FlagRush_Markers::FlagMarker_SetOnLandmark(Landmark);
}

Void Flag_SetAtPlayer(CSmPlayer Player, Integer StealResistanceEndDate) {
	FlagRush_Flag::SetAtCarrier(Player, StealResistanceEndDate);
	FlagRush_Markers::FlagMarker_SetOnPlayer(Player);
}

Void Flag_Pass(CSmPlayer Player, Integer StealResistanceEndDate) {
	FlagRush_Flag::PassFlag(Player, StealResistanceEndDate);
	FlagRush_Markers::FlagMarker_SetOnPlayer(Player);
}

Void Flag_Drop(Vec3 Position, Integer DropStateEndDate) {
	FlagRush_Flag::DropFlag(Position, DropStateEndDate);
	FlagRush_Markers::FlagMarker_SetOnPosition(Position);
}

Void Flag_Reset(Boolean Silent) {
	if (!Silent) FlagRush_Messages::FlagReset(C_Duration_EventMessage);

	declare CMapLandmark FlagSpawn;
	if (!S_RandomizeFlagSpawn) FlagSpawn = FlagRush_Map::GetDefaultFlagSpawn();
	else FlagSpawn = FlagRush_Map::GetRandomFlagSpawn();
	Flag_SetAtLandmark(FlagSpawn, Now + ML::NearestInteger(S_FlagRespawnDelaySeconds * 1000));
}

Void Flag_Reset() {
	Flag_Reset(False);
}
// #endregion

// #region Player
Void Player_Net_SendPosition(CSmPlayer Player) {
	declare netwrite Vec3 Net_Position for Player;
	Net_Position = Player.Position;
	declare netwrite Real Net_Yaw for Player;
	Net_Yaw = Player.AimYaw;
}

Boolean Player_RequestsClanChange(CSmPlayer Player) {
	return Player.CurrentClan != Player.RequestedClan;
}

Boolean Player_IsDead(CSmPlayer Player) {
	return Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && Player.Armor <= 0;
}

Void Player_Initialize(CSmPlayer Player) {
	Player.TrustClientSimu = !UsePvPCollisions && S_TrustClientSimu;
	Player.UseCrudeExtrapolation = !UsePvPCollisions && S_UseCrudeExtrapolation;
	Player.Dossard_Number = "  ";
	Player.Dossard_Color = <1., 1., 1.>;
	if (S_UseTeamSkins) Player.ForceModelId = FlagRush_Teams::GetSkinModelIdForTeam(Player.RequestedClan - 1);
	else Player.ForceModelId = NullId;
	SetPlayerClan(Player, Player.RequestedClan);
}

Boolean Player_CanSpawn(CSmPlayer Player) {
	if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) return False;
	declare netwrite Integer Net_SpawnDate for Player;
	return Net_SpawnDate < Now;
}

Void Player_Spawn(CSmPlayer Player) {
	Player_Initialize(Player);
	declare CMapLandmark SpawnLandmark = FlagRush_Map::GetSpawn(Player);
	if (SpawnLandmark != Null) {
		SpawnPlayer(Player, Player.CurrentClan, 1, SpawnLandmark.PlayerSpawn, Now + FlagRush_Common::C_SpawnAnimDuration);
	}
}

Void Player_Unspawn(CSmPlayer Player) {
	UnspawnPlayer(Player);
	declare netwrite Integer Net_SpawnDate for Player;
	Net_SpawnDate = Now + ML::NearestInteger(S_RespawnDelay * 1000);
}

Void Player_ApplyHandicaps(CSmPlayer Player) {
	if (S_FlagCarrierFragile) FlagRush_Handicaps::Queue_Fragile(Player, True);
	if (S_FlagCarrierAcceleration != 1.) FlagRush_Handicaps::Queue_AccelCoef(Player, S_FlagCarrierAcceleration);
	if (S_FlagCarrierControl != 1.) FlagRush_Handicaps::Queue_ControlCoef(Player, S_FlagCarrierControl);
	if (S_FlagCarrierAdherence != 1.) FlagRush_Handicaps::Queue_AdherenceCoef(Player, S_FlagCarrierAdherence);
}

Void Player_ResetHandicaps(CSmPlayer Player) {
	FlagRush_Handicaps::Queue_Reset(Player);
}

Boolean Player_CanPickUpDroppedFlag(CSmPlayer Player) {
	if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || Player.Armor <= 0) return False;
	declare Integer FlagRush_LastFlagDropDate for Player = -1;
	declare Boolean DidNotDropFlag = FlagRush_LastFlagDropDate != FlagRush_Flag::Get().LastDropDate;
	declare Boolean DropPickupPenaltyExpired = Now - FlagRush_LastFlagDropDate > ML::NearestInteger(S_DropFlagPickupPenalty * 1000);
	return (DidNotDropFlag || DropPickupPenaltyExpired) && Hitbox::AreColliding(Player, FlagRush_Flag::Get().Position);
}
// #endregion

// ================================================================= //
// Actions: FlagRush game logic related actions performed by players //
// ================================================================= //

// #region Actions
Void PickUpFlag(CSmPlayer Player) {
	FlagRush_Messages::FlagPickUp(Player, C_Duration_EventMessage);
	declare Integer StealResistanceEndDate = Now + ML::NearestInteger(S_FlagStealResistDurationSeconds * 1000);
	Flag_SetAtPlayer(Player, StealResistanceEndDate);
	Player_ApplyHandicaps(Player);
}

Void PassFlag(CSmPlayer Player) {
	// Old Carrier
	declare CSmPlayer OldCarrier = FlagRush_Flag::GetFlagCarrierPlayer();
	if (Player.CurrentClan != OldCarrier.CurrentClan) {
		FlagRush_Scores::OnPlayerStealFlag(Player);
		Player_ResetHandicaps(Player);
	}
	// New Carrier
	FlagRush_Messages::FlagPickUp(Player, C_Duration_EventMessage);
	declare Integer StealResistanceEndDate = Now + ML::NearestInteger(S_FlagStealResistDurationSeconds * 1000);
	Flag_Pass(Player, StealResistanceEndDate);
	Player_ApplyHandicaps(Player);
}

Void DropFlag(Vec3 Position) {
	// Save drop date
	declare CSmPlayer OldCarrierPlayer = FlagRush_Flag::GetFlagCarrierPlayer();
	if (OldCarrierPlayer != Null) { // Could be due to disconnect
		declare Integer FlagRush_LastFlagDropDate for OldCarrierPlayer;
		FlagRush_LastFlagDropDate = Now;
		Player_ResetHandicaps(OldCarrierPlayer);
	}

	declare CUser OldCarrierUser = FlagRush_Flag::Get().Carrier;
	FlagRush_Messages::FlagDropped(OldCarrierUser, C_Duration_EventMessage);
	declare DropStateEndDate = Now + ML::NearestInteger(S_FlagDropStateDurationSeconds * 1000);
	Flag_Drop(Position, DropStateEndDate);
}

Void DropFlag_LastSafePosition() {
	DropFlag(FlagRush_Flag::Get().LastSafePosition);
}

Void DropFlag_PreviousPosition() {
	DropFlag(FlagRush_Flag::Get().PrevPosition);
}

Void DropFlag() {
	declare CSmPlayer OldCarrierPlayer = FlagRush_Flag::GetFlagCarrierPlayer();
	declare Vec3 Position;
	if (OldCarrierPlayer != Null) Position = OldCarrierPlayer.Position;
	else Position = FlagRush_Flag::Get().Position;
	DropFlag(Position);
}

Void ScoreFlag(CSmPlayer Player) {
	FlagRush_Messages::FlagScored(Player, C_Duration_EventMessage);
	FlagRush_Scores::OnPlayerScoreFlag(Player.Score);
	// Check for assist
	declare FlagRush_Flag::K_FlagPass LastPass = FlagRush_Flag::Get().LastFlagPass;
	if (Now - LastPass.Date <= C_AssistTimeThreshold && LastPass.OldCarrier != Null) {
		declare CSmScore AssistScore = ModeUtils::GetScore(LastPass.OldCarrier.Login);
		if (AssistScore.TeamNum == Player.Score.TeamNum) {
			FlagRush_Scores::OnPlayerScoreFlagAssist(AssistScore);
		}
	}
	Flag_Reset(True);
	Player_ResetHandicaps(Player);
	if (S_UseTurns) MB_StopTurn();
}
// #endregion

// =========================================================== //
// "Event Callbacks": Resolve mode events to the right actions //
// =========================================================== //

// #region Event Callbacks
Void OnPlayerRequestsClanChange(CSmPlayer Player) {
	if (Player == FlagRush_Flag::GetFlagCarrierPlayer()) DropFlag();
	Player_Unspawn(Player);
	// Clan change handled by progression base
}

Void OnPlayerRequestsRespawn(CSmPlayer Player) {
	if (Player == FlagRush_Flag::GetFlagCarrierPlayer()) {
		DropFlag();
		return;
	}

	if (S_RespawnSpeedLimitKmh >= 0 && Player.Speed <= S_RespawnSpeedLimitKmh / 3.6) {
		Player_Unspawn(Player);
		return;
	}

	FlagRush_Flash::FlashRespawn(Player);
}

Void OnPlayerDeath(CSmPlayer Player) {
	if (Player == FlagRush_Flag::GetFlagCarrierPlayer()) DropFlag();
	Player_Unspawn(Player);
}

Void OnPlayerOutOfBound(CSmPlayer Player) {
	FlagRush_Messages::PlayerOutOfBounds(Player);
	if (Player == FlagRush_Flag::GetFlagCarrierPlayer()) DropFlag_LastSafePosition();
	Player_Unspawn(Player);
}

Void OnPlayerTriggersWaypoint(CSmPlayer Player, CMapLandmark Landmark) {
	if (FlagRush_Map::IsOutOfBoundsTrigger(Landmark)) {
		OnPlayerOutOfBound(Player);
	} else if (FlagRush_Flag::Get().Landmark == Landmark && Now > FlagRush_Flag::Get().CurrentStateEndDate) {
		PickUpFlag(Player);
	} else if (Player == FlagRush_Flag::GetFlagCarrierPlayer()){
		declare Integer TargetBaseClan;
		if (S_UseReversedBases) {
			TargetBaseClan = Player.CurrentClan;
		} else {
			TargetBaseClan = 3 - Player.CurrentClan;
		}
		if (FlagRush_Map::GetBases(TargetBaseClan).exists(Landmark)) {
			ScoreFlag(Player);
		}
	}
}

Void OnGameplayCommand(CommandUtils::K_Command Command) {
	declare Text CommandSource = CommandUtils::ResolveSource(Command);
	declare Text CommandText;
	switch (Command.Name) {
		case C_Command_ResetFlag: {
			Flag_Reset();
			CommandText = "The flag was reset.";
		}
		default: return;
	}
	declare Text Message = """{{{ FlagRush_Common::C_LogPrefix }}} Received command "{{{ TL::Replace(Command.Name, CommandUtils::C_CommandPrefix, "") }}}" by {{{ CommandSource }}}.""";
	if (CommandText != "") Message ^= " " ^ CommandText;
	UIManager.UIAll.SendChat(Message);
}
// #endregion