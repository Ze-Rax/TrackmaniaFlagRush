#Extends "Libs/Zrx/ModeLibs/BaseModes/FlagRushProgressionBase.Script.txt"

#Const	CompatibleMapTypes						"Trackmania\\FlagRushArena,FlagRushArena"
#Const	Version												"1.3.0-dev"
#Const	ScriptName										"Modes/TrackMania/FlagRush.Script.txt"

///////////////
// Libraries //
///////////////

// !! Commented out libs are already included in base mode, but added in here for Intellisense.

// General Libs
// #Include "TextLib" as TL
// #Include "MathLib" as ML

// #Include "Libs/Zrx/ModeLibs/Common/EventFeed.Script.txt"										as EventFeed
// #Include "Libs/Zrx/ModeLibs/Common/Commands/ModeCommands.Script.txt"				as ModeCommands
// #Include "Libs/Zrx/ModeLibs/Common/Commands/CommandUtils.Script.txt"				as CommandUtils
// #Include "Libs/Zrx/ModeLibs/Common/ModeUtils.Script.txt"										as ModeUtils
// #Include "Libs/Zrx/ModeLibs/Common/WarmUpReadyUp/WarmUpReadyUp.Script.txt"	as WarmUpReadyUp

// FlagRush Libs
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Common.Script.txt"						as FlagRush_Common
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Map.Script.txt"								as FlagRush_Map
// #Include "Libs/Zrx/ModeLibs/FlagRush/UI/FlagRush_Messages.Script.txt"				as FlagRush_Messages
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Scores.Script.txt"						as FlagRush_Scores
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_MatchEvaluation.Script.txt"		as FlagRush_MatchEvaluation
// #Include "Libs/Zrx/ModeLibs/FlagRush/GameplayPhase.Script.txt"							as FlagRush_GameplayPhase
// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Teams.Script.txt"							as FlagRush_Teams
#Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Player.Script.txt"							as FlagRush_Player
#Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_FlagState.Script.txt"						as FlagRush_Flag
#Include "Libs/Zrx/ModeLibs/FlagRush/UI/Modules/Flash.Script.txt"							as FlagRush_Flash


// #Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_UI2.Script.txt"								as FlagRush_UI

///////////////
// Constants //
///////////////

#Const C_Duration_IngameMessage 1500

//////////////
// Settings //
//////////////

#Setting S_UseCrudeExtrapolation						False		as "<hidden>"
#Setting S_TrustClientSimu									True		as "<hidden>"

// Gameplay
#Setting S_UseReversedBases									False 	as "<hidden>" // Switch team bases
#Setting S_RandomizeFlagSpawn								True 		as "<hidden>" // Randomize flag spawn location
#Setting S_FlagInitialSpawnDelaySeconds			0. 			as "<hidden>" // Initial flag spawn delay (seconds)
#Setting S_FlagRespawnDelaySeconds					0. 			as "<hidden>" // Flag respawn delay (seconds)
#Setting S_FlagDropStateDurationSeconds			8. 			as "<hidden>" // Flag drop state duration (seconds)
#Setting S_FlagStealResistDurationSeconds		1. 			as "<hidden>" // Flag steal resistance (seconds)
#Setting S_FlagSameTeamSteal								True		as "<hidden>" // Team flag steal
#Setting S_FlagCarrierFragile								True		as "Flag carrier becomes fragile"
#Setting S_FlagCarrierAcceleration					0.7 		as "Flag carrier acceleration (0.0 - 1.0)"
#Setting S_FlagCarrierControl								1.0 		as "<hidden>" // Flag carrier steering control (0.0 - 1.0)
#Setting S_FlagCarrierAdherence							1.0 		as "<hidden>" // Flag carrier adherence (0.0 - 1.0)
#Setting S_RespawnSpeedLimitKmh							30.			as "<hidden>" // Speed limit for player to respawn
#Setting S_RespawnDelay											4.0 		as "Respawn Delay (seconds) (+1.5s Spawn animation)"
#Setting S_DropFlagPickupPenalty						3.			as "<hidden>" // Flag pickup cooldown after dropping (seconds)
#Setting S_DropFlagOnTeleportDetection			True		as "<hidden>"
#Setting S_UseCollisions										False		as "Use collisions (experimental)"

// Teams
#Setting S_Team1Name 												"" 			as "Force Team 1 Name"
// #Setting S_Team1Color 											"" 			as "Force Team 1 Color"
#Setting S_Team2Name 												"" 			as "Force Team 2 Name"
// #Setting S_Team2Color 											"" 			as "Force Team 2 Color"
#Setting S_UseClubTags											True		as "Use club tags for team names"
#Setting S_UseTeamSkins											True		as "Use colored skins for teams"

//////////////
// Commands //
//////////////

// Constants are used for Commands from other sources, like UI Events.
// Constants value has to be the same as the name of the respective command without the Command_ prefix.
// The Parameter for the Command has to be sent with the Event in the Params array.
// In case of Vec2/Vec3/Int2/Int3 commands, X, Y & Z each take a seperate entry in the params array.
#Command	Command_ResetFlag								(Boolean) as		"Reset flag"
#Const		C_Command_ResetFlag															"ResetFlag"

// ~~~~~~~~~~ Setup ~~~~~~~~~~ //

***LoadLibraries***
***
ModeCommands::AddQuickCommand(C_Command_ResetFlag, "UICommon64_1", "Flag_light");
***

// ~~~~~~~~~~ Turn ~~~~~~~~~~ //

***StartTurn***
***
FlagRush_Flag::SetAtLandmark(FlagRush_Map::GetDefaultFlagSpawn());
***

***EndTurn***
***
foreach (Player in Players) {
	UnspawnPlayer(Player);
}
***

// ~~~~~~~~~~ PlayLoop ~~~~~~~~~~ //

***PlayLoop***
***
FlagRush_Flag::Yield();

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnPlayerTriggersWaypoint: OnPlayerTriggersWaypoint(Event.Player, Event.Landmark);
		case CSmModeEvent::EType::OnPlayerRequestRespawn: OnPlayerRequestsRespawn(Event.Player);
	}
}

foreach (Player in Players) {
	if (FlagRush_Player::RequestsClanChange(Player)) OnPlayerRequestsClanChange(Player);
	if (FlagRush_Player::IsDead(Player)) OnPlayerDeath(Player);
	if (FlagRush_Player::CanSpawn(Player)) FlagRush_Player::Spawn(Player);

	FlagRush_Player::Net_SendPosition(Player);
}
***

// ~~~~~~~~~~ WarmUp ~~~~~~~~~~ //

***WarmUpLoop***
***
foreach (Player in Players) {
	if (FlagRush_Player::RequestsClanChange(Player) || FlagRush_Player::IsDead(Player)) {
		UnspawnPlayer(Player);
	}

	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
		FlagRush_Player::Initialize(Player, S_UseTeamSkins, S_TrustClientSimu, S_UseCrudeExtrapolation);
		declare CMapSpawn Spawn = FlagRush_Map::GetSpawn(Player).PlayerSpawn;
		SpawnPlayer(Player, Player.CurrentClan, 100, Spawn, Now + FlagRush_Common::C_SpawnAnimDuration);
	}

	FlagRush_Player::Net_SendPosition(Player);
}

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			UnspawnPlayer(Event.Player);
		}
		case CSmModeEvent::EType::OnPlayerTriggersWaypoint: {
			if (FlagRush_Map::IsOutOfBoundsTrigger(Event.Landmark)) {
				FlagRush_Messages::PlayerOutOfBounds(Event.Player);
				UnspawnPlayer(Event.Player);
			}
		}
	}
}
***

***EndWarmUp***
***
foreach (Player in Players) {
	UnspawnPlayer(Player);
}
***

///////////////
// Functions //
///////////////

Void PickUpFlag(CSmPlayer Player) {
	FlagRush_Messages::FlagPickUp(Player, C_Duration_IngameMessage);
	FlagRush_Flag::SetAtCarrier(Player);
}

Void ScoreFlag(CSmPlayer Player) {

}

Void DropFlag(Boolean SafePosition) {
	declare CUser OldCarrierUser = FlagRush_Flag::Get().Carrier;
	FlagRush_Messages::FlagDropped(OldCarrierUser, C_Duration_IngameMessage);
	FlagRush_Flag::DropFlag(SafePosition);
}

Void DropFlag() {
	DropFlag(False);
}

Void FlagRush_UnspawnPlayer(CSmPlayer Player) {
	if(Player == FlagRush_Flag::GetFlagCarrierPlayer()) {
		DropFlag();
	}
	FlagRush_Player::Unspawn(Player);
	declare netwrite Integer Net_SpawnDate for Player;
	Net_SpawnDate = Now + ML::NearestInteger(S_RespawnDelay * 1000);
}

///////////////////////
// "Event Callbacks" //
///////////////////////

Void OnPlayerRequestsRespawn(CSmPlayer Player) {
	if (Player == FlagRush_Flag::GetFlagCarrierPlayer()) {
		DropFlag();
		return;
	}

	//log(Player.Speed);
	//log(S_RespawnSpeedLimitKmh / 3.6);
	if (S_RespawnSpeedLimitKmh >= 0 && Player.Speed <= S_RespawnSpeedLimitKmh / 3.6) {
		FlagRush_UnspawnPlayer(Player);
		return;
	}

	FlagRush_Flash::FlashRespawn(Player);

}

Void OnPlayerDeath(CSmPlayer Player) {
	FlagRush_UnspawnPlayer(Player);
}

Void OnPlayerOutOfBound(CSmPlayer Player) {
	FlagRush_Messages::PlayerOutOfBounds(Player);
	DropFlag(True);
	FlagRush_UnspawnPlayer(Player);
}

Void OnPlayerTriggersWaypoint(CSmPlayer Player, CMapLandmark Landmark) {
	if (FlagRush_Map::IsOutOfBoundsTrigger(Landmark)) {
		OnPlayerOutOfBound(Player);
	} else if (FlagRush_Flag::Get().Landmark == Landmark) {
		PickUpFlag(Player);
	} else {
		declare Integer TargetBaseClan;
		if (S_UseReversedBases) TargetBaseClan = Player.CurrentClan;
		else TargetBaseClan = 3 - Player.CurrentClan;
		if (FlagRush_Map::GetBases(TargetBaseClan).exists(Landmark)) ScoreFlag(Player);
	}
}

Void OnPlayerRequestsClanChange(CSmPlayer Player) {

}

Void OnPlayerPicksUpFlag(CSmPlayer NewCarrier) {

}

Void OnPlayerDropsFlag(CSmPlayer Player) {

}

Void OnPlayerStealsFlag(CSmPlayer NewCarrier, CSmPlayer OldCarrier) {

}

Void OnPlayerScoresFlag(CSmPlayer Scorer, CSmPlayer AssistNullable) {

}