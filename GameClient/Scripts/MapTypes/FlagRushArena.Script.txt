/**
*  Trackmania FlagRush
*
*  Exactly one StartTeam1
*  Exactly one StartTeam2
*  At least one BaseTeam1 and same amount of BaseTeam2
*  At least one FlagSpawn
*/

#RequireContext CSmMapType

#Const Version "2022-09-18"
#Const C_MapTypeVersion 1
#Const ScriptName "MapTypes/FlagRushArena.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "ColorLib" as CL

#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "Libs/Nadeo/ModeLibs/Legacy/MapType.Script.txt" as MapType
#Include "Libs/Nadeo/TMxSM/Race/Landmark.Script.txt" as Landmark
#Include "Libs/Nadeo/TMxSM/Race/MapSet.Script.txt" as MapSet
#Include "Libs/Nadeo/TMxSM/Race/MapGet.Script.txt" as MapGet
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/ClubStore.Script.txt" as ClubStore
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ClubStruct.Script.txt" as ClubStruct
#Include "Libs/Nadeo/CommonLibs/Common/ReportContext.Script.txt" as ReportContext
#Include "Libs/Nadeo/TMNext/TrackMania/Editor/MapType.Script.txt" as TMMapType
#Include "Modes/TrackMania/TM_RaceTest_Local.Script.txt" as RaceTest

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

#Const C_Debug													True
#Const C_Debug_ButtonActivatorOpacity		0.0
#Const C_Debug_ButtonActivatorColor			"F0F"

#Const C_WaypointType_Start							"Start"
#Const C_WaypointType_Finish						"Finish"
#Const C_WaypointType_Checkpoint				"Checkpoint"
#Const C_WaypointType_StartFinish				"StartFinish"
#Const C_WaypointType_None							"None"

#Const C_AnchorTag_Spawn_Prefix					"SpawnTeam"
#Const C_AnchorTag_Base_Prefix					"BaseTeam"
#Const C_AnchorTag_FlagSpawn						"FlagSpawn"
#Const C_AnchorTag_DefaultFlagSpawn			"DefaultFlagSpawn"
#Const C_AnchorTag_OutOfBoundsTrigger 	"FlagResetTrigger"

#Const C_AnchorTag_UnusedStart					"Unused Start"
#Const C_AnchorTag_UnusedFinish					"Unused Finish"
#Const C_AnchorTag_UnusedCheckpoint			"Unused Checkpoint"
#Const C_AnchorTag_UnusedStartFinish		"Unused Multilap"
#Const C_AnchorTag_UnusedLandmark				"Unused Landmark"

#Const C_UI_BackgroundOpacity						0.75
#Const C_UI_ButtonOpacity								0.75

#Const C_DefaultTeamHues 								[1 => 0.666, 2 => 0.]
#Const C_TeamHue_Default 								-1.

// Events from and to UI Layers
#Const C_UIEventType_ToggleTeamColorsWindow										"ToggleTeamColorsWindow"
#Const C_UIEventType_SetTeamColorHue													"SetTeamColorHue"
#Const C_UIEventType_SetEditLandmarkData											"SetEditLandmarkData"
#Const C_UIEventType_EditLandmark															"EditLandmark"

#Const C_UIEventData_EditLandmark_Unused											"EditLandmark_Unused"
#Const C_UIEventData_EditLandmark_Team												"EditLandmark_Team"
#Const C_UIEventData_EditLandmark_Function_FlagSpawn					"EditLandmark_Function_FlagSpawn"
#Const C_UIEventData_EditLandmark_Function_DefaultFlagSpawn		"EditLandmark_Function_DefaultFlagSpawn"
#Const C_UIEventData_EditLandmark_Function_OutOfBoundsTrigger	"EditLandmark_Function_OutOfBoundsTrigger"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structs
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

// Needs to be same as in Block property manialink
#Struct K_SelectedLandmark {
	Ident Id;
	Text WaypointType;
	Text Tag;
	Integer Order;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globables
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

declare K_SelectedLandmark G_SelectedLandmark;

declare CUILayer G_Toolbar;
declare CUILayer G_TeamColorsWindow;
declare CUILayer G_AnchorPropertiesWindow;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Layers
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

/**
 * Manialink page with buttons to be added in the editor toolbar.
 * Sends Layer custom events when buttons are clicked.
 */
Text GetToolbarManialink() {
	return """
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<manialink version="3" name="FlagRushArena_Toolbar">
	<frame id="teamcolor" pos="42 -84.5">
		<quad id="background" z-index="-1" size="12 10" halign="center" valign="center" style="UICommon128_1" substyle="BgFrameTilted2" opacity="{{{ C_UI_BackgroundOpacity }}}" />
		<quad id="button" size="7 7" z-index="1" halign="center" valign="center" style="UICommon64_1" substyle="Flag_dark" scriptevents="1" tooltip="FlagRush Teams" />
	</frame>

	<script><!--
	main() {
		declare CMlQuad ButtonTeamColors <=> (Page.GetFirstChild("button") as CMlQuad);

		while(True) {
			yield;

			foreach (Event in PendingEvents) {
				switch (Event.Type) {
					case CMlScriptEvent::Type::MouseClick: {
						switch (Event.Control) {
							case ButtonTeamColors: {
								SendCustomEvent("{{{ C_UIEventType_ToggleTeamColorsWindow }}}", []);
							}
						}
					}
				}
			}
		}
	}
	--></script>
</manialink>
	""";
}

/**
 * Manialink page to adjust the color of the teams.
 * Sends layer custom events when colors are reset or adjusted.
 */
Text GetTeamColorWindowManialink() {
	return """
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<manialink version="3" name="FlagRushArena_TeamColorsWindow">
	<framemodel id="teamcolorselector">
		<label id="header" pos="0 0" z-index="0" size="20 5" text="Team X" halign="center" valign="center2" textfont="GameFontSemiBold"/>
		<frame pos="0 -8" size="45 6" halign="center" valign="center">
			<colorpicker id="colorpicker" pos="-20 39.75" z-index="0" size="40 40" scriptevents="1" />
		</frame>
		<label id="hue-label" pos="0 -16" z-index="0" size="30 5" text="180" halign="center" valign="center2" textfont="GameFontRegular" textprefix="Hue: "/>
		<label id="reset" pos="0 -24" z-index="0" size="30 5" text="Reset to default" halign="center" valign="center2" style="CardButtonMedium" scriptevents="1" />
	</framemodel>

	<quad pos="0 0" z-index="-1" size="100 60" style="UICommon64_1" substyle="BgFrame1"  colorize="{{{ColorPalette::C_Color_GreenThree}}}" halign="center" valign="center" />
	<label pos="0 22.5" z-index="0" size="90 10" text="FlagRush Team Colors" halign="center" valign="center2" textfont="GameFontBlack" textsize="5" />

	<frameinstance modelid="teamcolorselector" id="team-1-color" pos="-25 10"/>
	<frameinstance modelid="teamcolorselector" id="team-2-color" pos="25 10"/>

	<label id="close" pos="0 -24" z-index="0" size="20 5" text="Close" style="CardButtonMediumL" valign="center" halign="center" scriptevents="1"/>

	<script><!--
	#Include "ColorLib" as CL
	#Include "TextLib" as TL

	#Const C_DefaultTeamHues [1 => {{{ C_DefaultTeamHues[1] }}}, 2 => {{{ C_DefaultTeamHues[2] }}}]

	#Struct K_TeamColorPicker {
		CMlFrame Frame;
		CMlLabel Header;
		CMlColorPicker ColorPicker;
		CMlLabel HueLabel;
		CMlLabel ResetButton;
	}

	declare Real[Integer] TeamHues;
	declare K_TeamColorPicker[Integer] G_TeamColorPickers;
	declare CMlLabel G_CloseButton;

	/**
	 * Updates the label below the hue selection slider with the appropriate value in range [0., 360.).
	 */
	Void UpdateHueLabel(Integer Clan) {
		declare CMlLabel HueLabel = G_TeamColorPickers[Clan].HueLabel;
		declare Real Hue = TeamHues.get(Clan, {{{ C_TeamHue_Default }}});
		if (Hue == {{{ C_TeamHue_Default }}}) {
			HueLabel.Value = "Default";
		} else {
			HueLabel.Value = TL::FormatReal(Hue * 360, 0, False, True);
		}
	}

	Void Team_SetHue(Integer Clan, Real Hue) {
		if (Hue == {{{ C_TeamHue_Default }}}) {
			G_TeamColorPickers[Clan].ColorPicker.Color = CL::HsvToRgb(<C_DefaultTeamHues[Clan], 1., 1.>);
		} else {
			G_TeamColorPickers[Clan].ColorPicker.Color = CL::HsvToRgb(<Hue, 1., 1.>);
		}
		TeamHues[Clan] = Hue;
		UpdateHueLabel(Clan);
	}

	Void Init() {
		// References
		G_CloseButton <=> (Page.GetFirstChild("close") as CMlLabel);

		// Team color pickers in window
		for (Clan, 1, 2) {
			declare K_TeamColorPicker TeamColorPicker;
			// References
			TeamColorPicker.Frame <=> (Page.GetFirstChild("team-" ^ Clan ^ "-color") as CMlFrame);
			TeamColorPicker.Header <=> (TeamColorPicker.Frame.GetFirstChild("header") as CMlLabel);
			TeamColorPicker.ColorPicker <=> (TeamColorPicker.Frame.GetFirstChild("colorpicker") as CMlColorPicker);
			TeamColorPicker.HueLabel <=> (TeamColorPicker.Frame.GetFirstChild("hue-label") as CMlLabel);
			TeamColorPicker.ResetButton <=> (TeamColorPicker.Frame.GetFirstChild("reset") as CMlLabel);

			G_TeamColorPickers[Clan] = TeamColorPicker;

			// Set initial values
			TeamColorPicker.Header.Value = "Team " ^ Clan;
			Team_SetHue(Clan, {{{ C_TeamHue_Default }}});
		}
	}

	main() {
		Init();

		declare Integer LastResetClicked = -1000;
		while (True) {
			foreach (Event in PendingEvents) {
				switch (Event.Type) {
					case CMlScriptEvent::Type::MouseClick: {
						if (Event.Control == G_CloseButton) {
							SendCustomEvent("{{{ C_UIEventType_ToggleTeamColorsWindow }}}", []);
						} else {
							foreach (Clan => TeamColorPicker in G_TeamColorPickers) {
								switch (Event.Control) {
									case TeamColorPicker.ColorPicker: {
										// Setting a color (on reset) fires a Mouse click event on the color picker. Ignore that.
										if (Now - Period == LastResetClicked) {
											break;
										}

										declare Real Hue = CL::RgbToHsv(TeamColorPicker.ColorPicker.Color).X;
										SendCustomEvent("{{{ C_UIEventType_SetTeamColorHue }}}", [TL::ToText(Clan), TL::ToText(Hue)]);
										TeamHues[Clan] = Hue;
										UpdateHueLabel(Clan);
									}
									case TeamColorPicker.ResetButton: {
										SendCustomEvent("{{{ C_UIEventType_SetTeamColorHue }}}", [TL::ToText(Clan), TL::ToText({{{ C_TeamHue_Default }}})]);
										Team_SetHue(Clan, {{{ C_TeamHue_Default }}});
										LastResetClicked = Now;
									}
								}
							}
						}
					}
					case CMlScriptEvent::Type::PluginCustomEvent: {
						// Hue was forced by maptype script
						if (Event.CustomEventType == "{{{ C_UIEventType_SetTeamColorHue }}}") {
							declare Integer Clan = TL::ToInteger(Event.CustomEventData[0]);
							declare Real Hue = TL::ToReal(Event.CustomEventData[1]);
							Team_SetHue(Clan, Hue);
							LastResetClicked = Now;
						}
					}
				}
			}

			yield; // Yield at the end to catch initialization events from maptype script
		}
	}
	--></script>
</manialink>
	""";
}

/**
 * Manialink page to adjust properties of anchors
 * Sends layer custom events when properties should be updated.
 */
Text GetEditAnchorManialink() {
	return """
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<manialink version="3" name="FlagRushArena_AnchorEdit">
	<frame id="anchor-window" pos="132.5 50">
		<frame id="header">
			<quad pos="0 0" z-index="0" size="50 10" style="UICommon64_1" substyle="BgFrame1"  colorize="{{{ColorPalette::C_Color_GreenTwo}}}" halign="center" valign="center" opacity="{{{C_UI_BackgroundOpacity}}}"/>
			<label pos="0 0" z-index="1" size="45 8" text="LandmarkType" halign="center" valign="center" textsize="4" style="Default" textfont="GameFontSemiBold" id="label-header"/>
		</frame>

		<frame id="body" pos="0 -25">
			<frame id="body-teamselection" z-index="1" hidden="1">
			<quad pos="0 0" z-index="0" size="50 35" halign="center" valign="center" colorize="{{{ColorPalette::C_Color_GreenThree}}}" style="UICommon64_1" substyle="BgFrame1" opacity="{{{C_UI_BackgroundOpacity}}}"/>
				<label pos="0 10" size="45 8" text="Team:" halign="center" valign="center" style="Default" textfont="GameFontRegular" textsize="3" z-index="1" textcolor="FFF"/>

				<quad pos="-12.5 0" z-index="1" size="20 8" id="button-team1-bg" halign="center" valign="center" style="UICommon64_1" substyle="BgFrame1" opacity="{{{C_UI_ButtonOpacity}}}"/>
				<label pos="-12.5 0" z-index="2" size="20 6" text="Team 1" halign="center" valign="center" style="Default" textfont="GameFontBlack" />
				<quad pos="-12.5 0" z-index="3" size="20 8" id="button-team1-activator" halign="center" valign="center" opacity="{{{C_Debug_ButtonActivatorOpacity}}}" bgcolor="{{{C_Debug_ButtonActivatorColor}}}" scriptevents="1"/>

				<quad pos="12.5 0" z-index="1" size="20 8" id="button-team2-bg" halign="center" valign="center" style="UICommon64_1" substyle="BgFrame1" opacity="{{{C_UI_ButtonOpacity}}}"/>
				<label pos="12.5 0" z-index="2" size="20 6" text="Team 2" halign="center" valign="center" style="Default" textfont="GameFontBlack" />
				<quad pos="12.5 0" z-index="3" size="20 8" id="button-team2-activator" halign="center" valign="center" opacity="{{{C_Debug_ButtonActivatorOpacity}}}" bgcolor="{{{C_Debug_ButtonActivatorColor}}}" scriptevents="1"/>

				<quad pos="0 -10" z-index="1" size="45 8" id="button-teamnone-bg" halign="center" valign="center" style="UICommon64_1" substyle="BgFrame1"  colorize="{{{ColorPalette::C_Color_GreenTwo}}}" opacity="{{{C_UI_ButtonOpacity}}}"/>
				<label pos="0 -10" z-index="2" size="45 6" text="None" halign="center" valign="center" style="Default" textfont="GameFontBlack" />
				<quad pos="0 -10" z-index="3" size="45 8" id="button-teamnone-activator" halign="center" valign="center" opacity="{{{C_Debug_ButtonActivatorOpacity}}}" bgcolor="{{{C_Debug_ButtonActivatorColor}}}" scriptevents="1"/>
			</frame>

			<frame id="body-cpfunction" z-index="1" hidden="1">
				<quad pos="0 -10" z-index="0" size="50 55" halign="center" valign="center" colorize="{{{ColorPalette::C_Color_GreenThree}}}" style="UICommon64_1" substyle="BgFrame1" opacity="{{{C_UI_BackgroundOpacity}}}"/>
				<label pos="0 10" size="45 8" text="Function:" halign="center" valign="center" style="Default" textfont="GameFontRegular" textsize="3" z-index="1" textcolor="FFF"/>

				<quad pos="0 0" z-index="1" size="45 8" id="button-cpfunctionflag-bg" halign="center" valign="center" style="UICommon64_1" substyle="BgFrame1"  colorize="{{{ColorPalette::C_Color_GreenTwo}}}" opacity="{{{C_UI_ButtonOpacity}}}"/>
				<label pos="0 0" z-index="2" size="45 6" text="Flag spawn" halign="center" valign="center" style="Default" textfont="GameFontBlack" />
				<quad pos="0 0" z-index="3" size="45 8" id="button-cpfunctionflag-activator" halign="center" valign="center" opacity="{{{C_Debug_ButtonActivatorOpacity}}}" bgcolor="{{{C_Debug_ButtonActivatorColor}}}" scriptevents="1"/>

				<quad pos="17.5 -10" z-index="1" size="10 8" id="button-cpfunctionflagdefault-bg" halign="center" valign="center" style="UICommon64_1" substyle="BgFrame1"  colorize="{{{ColorPalette::C_Color_GreenTwo}}}" opacity="{{{C_UI_ButtonOpacity}}}"/>
				<label pos="-20 -10" z-index="2" size="30 6" id="button-cpfunctionflagdefault-label" text="Default flag spawn:" halign="left" valign="center" style="Default" textfont="GameFontBlack" />
				<label pos="17.5 -10" z-index="2" size="10 6" id="button-cpfunctionflagdefault-icon" text="" halign="center" valign="center" style="Default" textfont="GameFontBlack" textsize="4" />
				<quad pos="17.5 -10" z-index="3" size="10 8" id="button-cpfunctionflagdefault-activator" halign="center" valign="center" opacity="{{{C_Debug_ButtonActivatorOpacity}}}" bgcolor="{{{C_Debug_ButtonActivatorColor}}}" scriptevents="1"/>

				<quad pos="0 -20" z-index="1" size="45 8" id="button-cpfunctionreset-bg" halign="center" valign="center" style="UICommon64_1" substyle="BgFrame1"  colorize="{{{ColorPalette::C_Color_GreenTwo}}}" opacity="{{{C_UI_ButtonOpacity}}}"/>
				<label pos="0 -20" z-index="2" size="45 6" text="Flag Reset Trigger" halign="center" valign="center" style="Default" textfont="GameFontBlack" />
				<quad pos="0 -20" z-index="3" size="45 8" id="button-cpfunctionreset-activator" halign="center" valign="center" opacity="{{{C_Debug_ButtonActivatorOpacity}}}" bgcolor="{{{C_Debug_ButtonActivatorColor}}}" scriptevents="1"/>

				<quad pos="0 -30" z-index="1" size="45 8" id="button-cpfunctionnone-bg" halign="center" valign="center" style="UICommon64_1" substyle="BgFrame1"  colorize="{{{ColorPalette::C_Color_GreenTwo}}}" opacity="{{{C_UI_ButtonOpacity}}}"/>
				<label pos="0 -30" z-index="2" size="45 6" text="None" halign="center" valign="center" style="Default" textfont="GameFontBlack" />
				<quad pos="0 -30" z-index="3" size="45 8" id="button-cpfunctionnone-activator" halign="center" valign="center" opacity="{{{C_Debug_ButtonActivatorOpacity}}}" bgcolor="{{{C_Debug_ButtonActivatorColor}}}" scriptevents="1"/>
			</frame>

			<frame id="body-noedit" z-index="1" hidden="1">
			<quad pos="0 0" z-index="0" size="50 35" halign="center" valign="center" colorize="{{{ColorPalette::C_Color_GreenThree}}}" style="UICommon64_1" substyle="BgFrame1" opacity="{{{C_UI_BackgroundOpacity}}}"/>
				<label pos="0 10" size="45 8" text="Unsupported:" halign="center" valign="center" style="Default" textfont="GameFontSemibold" textsize="3" z-index="1" textcolor="{{{ColorPalette::C_Color_Bad}}}"/>
				<label pos="0 -5" size="45 18" text="This landmark is not supported and can therefore not be edited!" halign="center" valign="center" style="Default" textfont="GameFontRegular" textsize="2.5" z-index="1" autonewline="1" textcolor="FFF"/>
			</frame>
		</frame>

		<frame id="order" pos="-35 -15" hidden="1">
			<quad pos="0 0" z-index="0" size="15 15" halign="center" valign="center" colorize="{{{ColorPalette::C_Color_GreenThree}}}" style="UICommon64_1" substyle="BgFrame1" opacity="{{{C_UI_BackgroundOpacity}}}"/>
			<label pos="0 3.5" z-index="1" size="10 5" text="Order" halign="center" valign="center" style="Default" textfont="GameFontRegular" textsize="2" textcolor="FFF"/>
			<label pos="0 -1.5" z-index="1" size="10 8" text="0" halign="center" valign="center" style="Default" textfont="GameFontBlack" textsize="5" textcolor="FFF" id="label-ordervalue"/>

			<quad pos="0 10" z-index="0" size="8 5" bgcolor="FFF" opacity="0.7" style="UICommon64_2" substyle="ArrowUpSlim_light" valign="center" halign="center" scriptevents="1" id="button-order-up"/>
			<quad pos="0 -10" z-index="0" size="8 5" bgcolor="FFF" opacity="0.7" style="UICommon64_2" substyle="ArrowDownSlim_light" valign="center" halign="center" scriptevents="1" id="button-order-down"/>
		</frame>
	</frame>

	<script><!--
	#Include "TextLib" as TL
	#Include "ColorLib" as CL

	#Const C_DefaultTeamHues [1 => {{{ C_DefaultTeamHues[1] }}}, 2 => {{{ C_DefaultTeamHues[2] }}}]

	#Const C_ToggleButton_Active ""
	#Const C_ToggleButton_Inactive ""

	// Needs to be the same as in the main maptype script (except Id)
	#Struct K_SelectedLandmark {
		// Ident Id;
		Text WaypointType;
		Text Tag;
		Integer Order;
	}

	#Struct K_Button {
		CMlQuad Activator;
		CMlQuad Background;
	}

	#Struct K_ToggleButton {
		CMlQuad Activator;
		CMlQuad Background;
		CMlLabel Label;
		CMlLabel IconLabel;
	}

	#Struct K_Header {
		CMlFrame Frame;
		CMlLabel Label;
	}

	#Struct K_Body_TeamSelection {
		CMlFrame Frame;
		Vec3[Boolean][Integer] TeamButtonColors;
		K_Button[Integer] TeamButtons;
		K_Button ButtonNone;
	}

	#Struct K_Body_CPFunction {
		CMlFrame Frame;
		K_Button ButtonFlag;
		K_ToggleButton ToggleButtonDefaultSpawn;
		K_Button ButtonOutOfBounds;
		K_Button ButtonNone;
	}

	#Struct K_Body_NoEdit {
		CMlFrame Frame;
	}

	#Struct K_Order {
		CMlFrame Frame;
		CMlLabel Label;
		CMlQuad ButtonUp;
		CMlQuad ButtonDown;
	}

	declare K_SelectedLandmark G_SelectedLandmark;

	declare CMlFrame G_WrapperFrame;
	declare K_Header G_Header;
	declare K_Body_TeamSelection G_TeamSelection;
	declare K_Body_CPFunction G_CPFunction;
	declare K_Body_NoEdit G_NoEdit;
	declare K_Order G_Order;

	Void OnTeamHueChanged(Integer Clan, Real Hue) {
		if (Hue == {{{ C_TeamHue_Default }}}) {
			G_TeamSelection.TeamButtonColors[Clan] = [True => CL::HsvToRgb(<C_DefaultTeamHues[Clan], 1., 0.7>), False => CL::HsvToRgb(<C_DefaultTeamHues[Clan], 1., 1.>)];
		} else {
			G_TeamSelection.TeamButtonColors[Clan] = [True => CL::HsvToRgb(<Hue, 1., 0.5>), False => CL::HsvToRgb(<Hue, 1., 1.>)];
		}
		G_TeamSelection.TeamButtons[Clan].Background.Colorize = G_TeamSelection.TeamButtonColors[Clan][False];
	}

	Void InitMlControls() {
		G_WrapperFrame = (Page.GetFirstChild("anchor-window") as CMlFrame);

		G_Header.Frame = (Page.GetFirstChild("header") as CMlFrame);
		G_Header.Label = (Page.GetFirstChild("label-header") as CMlLabel);

		G_TeamSelection.Frame = (Page.GetFirstChild("body-teamselection") as CMlFrame);
		G_TeamSelection.TeamButtons[1] = K_Button{
			Activator = (Page.GetFirstChild("button-team1-activator") as CMlQuad),
			Background = (Page.GetFirstChild("button-team1-bg") as CMlQuad)
		};
		G_TeamSelection.TeamButtons[2] = K_Button{
			Activator = (Page.GetFirstChild("button-team2-activator") as CMlQuad),
			Background = (Page.GetFirstChild("button-team2-bg") as CMlQuad)
		};
		G_TeamSelection.ButtonNone.Activator = (Page.GetFirstChild("button-teamnone-activator") as CMlQuad);
		G_TeamSelection.ButtonNone.Background = (Page.GetFirstChild("button-teamnone-bg") as CMlQuad);

		G_CPFunction.Frame = (Page.GetFirstChild("body-cpfunction") as CMlFrame);
		G_CPFunction.ButtonFlag.Activator = (Page.GetFirstChild("button-cpfunctionflag-activator") as CMlQuad);
		G_CPFunction.ButtonFlag.Background = (Page.GetFirstChild("button-cpfunctionflag-bg") as CMlQuad);
		G_CPFunction.ToggleButtonDefaultSpawn.Activator = (Page.GetFirstChild("button-cpfunctionflagdefault-activator") as CMlQuad);
		G_CPFunction.ToggleButtonDefaultSpawn.Background = (Page.GetFirstChild("button-cpfunctionflagdefault-bg") as CMlQuad);
		G_CPFunction.ToggleButtonDefaultSpawn.Label = (Page.GetFirstChild("button-cpfunctionflagdefault-label") as CMlLabel);
		G_CPFunction.ToggleButtonDefaultSpawn.IconLabel = (Page.GetFirstChild("button-cpfunctionflagdefault-icon") as CMlLabel);
		G_CPFunction.ButtonOutOfBounds.Activator = (Page.GetFirstChild("button-cpfunctionreset-activator") as CMlQuad);
		G_CPFunction.ButtonOutOfBounds.Background = (Page.GetFirstChild("button-cpfunctionreset-bg") as CMlQuad);
		G_CPFunction.ButtonNone.Activator = (Page.GetFirstChild("button-cpfunctionnone-activator") as CMlQuad);
		G_CPFunction.ButtonNone.Background = (Page.GetFirstChild("button-cpfunctionnone-bg") as CMlQuad);

		G_NoEdit.Frame = (Page.GetFirstChild("body-noedit") as CMlFrame);

		G_Order.Frame = (Page.GetFirstChild("order") as CMlFrame);
		G_Order.Label = (Page.GetFirstChild("label-ordervalue") as CMlLabel);
		G_Order.ButtonUp = (Page.GetFirstChild("button-order-up") as CMlQuad);
		G_Order.ButtonDown = (Page.GetFirstChild("button-order-down") as CMlQuad);
	}

	Void UpdateDisplayedValues() {
		// Show the right frames
		G_TeamSelection.Frame.Visible = G_SelectedLandmark.WaypointType == "{{{ C_WaypointType_Start }}}" || G_SelectedLandmark.WaypointType == "{{{ C_WaypointType_Finish }}}";
		G_CPFunction.Frame.Visible = G_SelectedLandmark.WaypointType == "{{{ C_WaypointType_Checkpoint }}}";
		G_NoEdit.Frame.Visible = !(G_TeamSelection.Frame.Visible || G_CPFunction.Frame.Visible);
		G_Order.Frame.Visible = False; // Not used yet

		// Values
		G_Header.Label.Value = G_SelectedLandmark.WaypointType;

		if (G_SelectedLandmark.Tag == "{{{C_AnchorTag_FlagSpawn}}}" || G_SelectedLandmark.Tag == "{{{C_AnchorTag_DefaultFlagSpawn}}}") {
			G_CPFunction.ToggleButtonDefaultSpawn.Label.Opacity = 1.;
			G_CPFunction.ToggleButtonDefaultSpawn.IconLabel.Opacity = 1.;
			G_CPFunction.ToggleButtonDefaultSpawn.Background.Opacity = 1.;
			G_CPFunction.ToggleButtonDefaultSpawn.Activator.ScriptEvents_Restore();
		} else {
			G_CPFunction.ToggleButtonDefaultSpawn.Label.Opacity = 0.25;
			G_CPFunction.ToggleButtonDefaultSpawn.IconLabel.Opacity = 0.25;
			G_CPFunction.ToggleButtonDefaultSpawn.Background.Opacity = 0.25;
			G_CPFunction.ToggleButtonDefaultSpawn.Activator.ScriptEvents_Disable();
		}

		if (G_SelectedLandmark.Tag == "{{{C_AnchorTag_DefaultFlagSpawn}}}") {
			G_CPFunction.ToggleButtonDefaultSpawn.IconLabel.Value = C_ToggleButton_Active;
		} else {
			G_CPFunction.ToggleButtonDefaultSpawn.IconLabel.Value = C_ToggleButton_Inactive;
		}

		G_Order.Label.Value = TL::ToText(G_SelectedLandmark.Order);
	}

	main() {
		PageAlwaysUpdateScript = True; // By default False; Script sleeps if page is not visible; Anchor data event will be missed if False
		InitMlControls();

		while(True) {
			UpdateDisplayedValues();

			foreach(Event in PendingEvents) {
				switch (Event.Type) {
					case CMlScriptEvent::Type::MouseClick: {
						switch (Event.Control) {
							case G_TeamSelection.TeamButtons[1].Activator: SendCustomEvent("{{{ C_UIEventType_EditLandmark }}}", ["{{{ C_UIEventData_EditLandmark_Team }}}", "1"]);
							case G_TeamSelection.TeamButtons[2].Activator: SendCustomEvent("{{{ C_UIEventType_EditLandmark }}}", ["{{{ C_UIEventData_EditLandmark_Team }}}", "2"]);
							case G_TeamSelection.ButtonNone.Activator: SendCustomEvent("{{{ C_UIEventType_EditLandmark }}}", ["{{{ C_UIEventData_EditLandmark_Unused }}}"]);
							case G_CPFunction.ButtonFlag.Activator: SendCustomEvent("{{{ C_UIEventType_EditLandmark }}}", ["{{{ C_UIEventData_EditLandmark_Function_FlagSpawn }}}"]);
							case G_CPFunction.ToggleButtonDefaultSpawn.Activator: SendCustomEvent("{{{ C_UIEventType_EditLandmark }}}", ["{{{ C_UIEventData_EditLandmark_Function_DefaultFlagSpawn }}}"]);
							case G_CPFunction.ButtonOutOfBounds.Activator: SendCustomEvent("{{{ C_UIEventType_EditLandmark }}}", ["{{{ C_UIEventData_EditLandmark_Function_OutOfBoundsTrigger }}}"]);
							case G_CPFunction.ButtonNone.Activator: SendCustomEvent("{{{ C_UIEventType_EditLandmark }}}", ["{{{ C_UIEventData_EditLandmark_Unused }}}"]);
						}
					}
					case CMlScriptEvent::Type::MouseOver: {
						switch (Event.Control) {
							case G_TeamSelection.TeamButtons[1].Activator: G_TeamSelection.TeamButtons[1].Background.Colorize = G_TeamSelection.TeamButtonColors[1][True];
							case G_TeamSelection.TeamButtons[2].Activator: G_TeamSelection.TeamButtons[2].Background.Colorize = G_TeamSelection.TeamButtonColors[2][True];
							case G_TeamSelection.ButtonNone.Activator: G_TeamSelection.ButtonNone.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenThree}}};
							case G_CPFunction.ButtonFlag.Activator: G_CPFunction.ButtonFlag.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenThree}}};
							case G_CPFunction.ButtonNone.Activator: G_CPFunction.ButtonNone.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenThree}}};
							case G_CPFunction.ToggleButtonDefaultSpawn.Activator: G_CPFunction.ToggleButtonDefaultSpawn.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenThree}}};
							case G_CPFunction.ButtonOutOfBounds.Activator: G_CPFunction.ButtonOutOfBounds.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenThree}}};
						}
					}
					case CMlScriptEvent::Type::MouseOut: {
						switch (Event.Control) {
							case G_TeamSelection.TeamButtons[1].Activator: G_TeamSelection.TeamButtons[1].Background.Colorize = G_TeamSelection.TeamButtonColors[1][False];
							case G_TeamSelection.TeamButtons[2].Activator: G_TeamSelection.TeamButtons[2].Background.Colorize = G_TeamSelection.TeamButtonColors[2][False];
							case G_TeamSelection.ButtonNone.Activator: G_TeamSelection.ButtonNone.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenTwo}}};
							case G_CPFunction.ButtonFlag.Activator: G_CPFunction.ButtonFlag.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenTwo}}};
							case G_CPFunction.ButtonNone.Activator: G_CPFunction.ButtonNone.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenTwo}}};
							case G_CPFunction.ToggleButtonDefaultSpawn.Activator: G_CPFunction.ToggleButtonDefaultSpawn.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenTwo}}};
							case G_CPFunction.ButtonOutOfBounds.Activator: G_CPFunction.ButtonOutOfBounds.Background.Colorize = {{{ColorPalette::C_Color_Vec3_GreenTwo}}};
						}
					}
					case CMlScriptEvent::Type::PluginCustomEvent: {
						switch (Event.CustomEventType) {
							case "{{{ C_UIEventType_SetEditLandmarkData }}}": {
								G_SelectedLandmark.fromjson(Event.CustomEventData[0]);
							}
							case "{{{ C_UIEventType_SetTeamColorHue }}}": {
								declare Integer Clan = TL::ToInteger(Event.CustomEventData[0]);
								declare Real Hue = TL::ToReal(Event.CustomEventData[1]);
								OnTeamHueChanged(Clan, Hue);
							}
						}
					}
				}
			}

			yield; // Yield at the end to catch initialization events from maptype script
		}
	}
	--></script>
</manialink>
	""";
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

/**
 * Checks if all the requried landmarks are present.
 * If true: Sets the map status to valid
 * If false: Sets the map status to invalid; Sets the validability requirements message (shown when user clicks validation flag)
 */
Void UpdateValidability() {
	declare SpawnsTeam1Count = 0;
	declare SpawnsTeam2Count = 0;
	declare BasesTeam1Count = 0;
	declare BasesTeam2Count = 0;
	declare FlagSpawnsCount = 0;
	declare DefaultFlagSpawnsCount = 0;

	foreach (Anchor in AnchorData) {
		switch (Anchor.WaypointType) {
			case CAnchorData::EWaypointType::Start: {
				if (Anchor.Tag == """{{{C_AnchorTag_Spawn_Prefix}}}1""") SpawnsTeam1Count += 1;
				else if (Anchor.Tag == """{{{C_AnchorTag_Spawn_Prefix}}}2""") SpawnsTeam2Count += 1;
			}
			case CAnchorData::EWaypointType::Finish: {
				if (Anchor.Tag == """{{{C_AnchorTag_Base_Prefix}}}1""") BasesTeam1Count += 1;
				else if (Anchor.Tag == """{{{C_AnchorTag_Base_Prefix}}}2""") BasesTeam2Count += 1;
			}
			case CAnchorData::EWaypointType::StartFinish: {
				// What to do with multilaps?
			}
			case CAnchorData::EWaypointType::Checkpoint: {
				if (Anchor.Tag == C_AnchorTag_FlagSpawn) FlagSpawnsCount += 1;
				else if (Anchor.Tag == C_AnchorTag_DefaultFlagSpawn) {
					FlagSpawnsCount += 1;
					DefaultFlagSpawnsCount += 1;
				}
			}
		}
	}

	declare IsValid = True;
	declare Message = "$fff$sYour map is missing the following reqirements:\n";

	if (SpawnsTeam1Count != 1) {
		IsValid = False;
		Message ^= "\n" ^ """You must place exactly one $44f{{{C_AnchorTag_Spawn_Prefix}}}1$fff! ({{{SpawnsTeam1Count}}}/1)""";
	}
	if (SpawnsTeam2Count != 1) {
		IsValid = False;
		Message ^= "\n" ^ """You must place exactly one $f44{{{C_AnchorTag_Spawn_Prefix}}}2$fff! ({{{SpawnsTeam2Count}}}/1)""";
	}
	if (BasesTeam1Count  < 1) {
		IsValid = False;
		Message ^= "\n" ^ """You must place at least one $44f{{{C_AnchorTag_Base_Prefix}}}1$fff! ({{{BasesTeam1Count}}}/1)""";
	}
	if (BasesTeam2Count  < 1) {
		IsValid = False;
		Message ^= "\n" ^ """You must place at least one $f44{{{C_AnchorTag_Base_Prefix}}}2$fff! ({{{BasesTeam1Count}}}/1)""";
	}
	if (BasesTeam1Count != BasesTeam2Count) {
		IsValid = False;
		Message ^= "\n" ^ """You must place as many $44f{{{C_AnchorTag_Base_Prefix}}}1$fff as $f44{{{C_AnchorTag_Base_Prefix}}}2$fff! ($44f{{{BasesTeam1Count}}}$fff-$f44{{{BasesTeam2Count}}}$fff)""";
	}
	if (FlagSpawnsCount  < 1) {
		IsValid = False;
		Message ^= "\n" ^ """You must place at least one {{{C_AnchorTag_FlagSpawn}}}!""";
	}
	if (DefaultFlagSpawnsCount == 0) {
		IsValid = False;
		Message ^= "\n" ^ """You haven't set a default {{{C_AnchorTag_FlagSpawn}}}!""";
	}
	if (DefaultFlagSpawnsCount > 1) {
		IsValid = False;
		Message ^= "\n" ^ """You cannot have more than one default {{{C_AnchorTag_FlagSpawn}}}! ({{{DefaultFlagSpawnsCount}}}/1)""";
	}
	Message ^= "\n\n" ^ "Need help? Check out $4cf$l[https://docs.google.com/document/d/e/2PACX-1vRVujmSYunjz7mrLf5sTF4BDS7GwayxjWyY8clXgyiZzgH_EYz0d7mx2EJHu0FdNoyoJgPyEpkD-yoe/pub]this FlagRush Mapping Guide$l$fff by Realspace!";

	if (IsValid) {
		ValidationStatus = CMapType::ValidationStatus::Validated;
	} else {
		ValidationStatus = CMapType::ValidationStatus::NotValidable;
	}
	ValidabilityRequirementsMessage = Message;
}

/**
 * Saves a reference to the landmark that was selected with the block property tool.
 * Also sents the data of the landmark to the block property UI window.
 */
Void SetSelectedAnchor(Ident AnchorId) {
	G_SelectedLandmark = K_SelectedLandmark{ Id = AnchorId };
	if (AnchorId != NullId) {
		declare CAnchorData Anchor <=> AnchorData[AnchorId];
		G_SelectedLandmark.Tag = Anchor.Tag;
		G_SelectedLandmark.Order = Anchor.Order;
		switch (Anchor.WaypointType) {
			case CAnchorData::EWaypointType::Start:  G_SelectedLandmark.WaypointType = C_WaypointType_Start;
			case CAnchorData::EWaypointType::Finish:  G_SelectedLandmark.WaypointType = C_WaypointType_Finish;
			case CAnchorData::EWaypointType::Checkpoint:  G_SelectedLandmark.WaypointType = C_WaypointType_Checkpoint;
			case CAnchorData::EWaypointType::StartFinish:  G_SelectedLandmark.WaypointType = C_WaypointType_StartFinish;
			default: G_SelectedLandmark.WaypointType = C_WaypointType_None;
		}
	}
	LayerCustomEvent(G_AnchorPropertiesWindow, C_UIEventType_SetEditLandmarkData, [G_SelectedLandmark.tojson()]);
}

/**
 * Sets the anchor to be ignored by the gamemode.
 */
Void Anchor_SetUnused(CAnchorData Anchor) {
	switch (Anchor.WaypointType) {
		case CAnchorData::EWaypointType::Start: Anchor.Tag = C_AnchorTag_UnusedStart;
		case CAnchorData::EWaypointType::Finish: Anchor.Tag = C_AnchorTag_UnusedFinish;
		case CAnchorData::EWaypointType::StartFinish: Anchor.Tag = C_AnchorTag_UnusedStartFinish;
		case CAnchorData::EWaypointType::Checkpoint: Anchor.Tag = C_AnchorTag_UnusedCheckpoint;
		default: Anchor.Tag = C_AnchorTag_UnusedLandmark;
	}
}

/**
 * Sets the anchor as a flag spawn.
 * Does not do anything if the anchor is not suitable for flag spawns.
 */
Void Anchor_SetFlagSpawn(CAnchorData Anchor) {
	declare Boolean IsCheckpoint = Anchor.WaypointType == CAnchorData::EWaypointType::Checkpoint;
	if (C_Debug) {
		assert(IsCheckpoint, "Selected landmark is not a checkpoint");
	} else {
		if (!IsCheckpoint) return;
	}
	Anchor.Tag = C_AnchorTag_FlagSpawn;
}

/**
 * Sets the anchor as default flagspawn or common flagspawn, depending it's current state.
 * Does not do anythign if the anchor is not suitable for flag spawn.
 */
Void Anchor_ToggleDefaultFlagSpawn(CAnchorData Anchor) {
	declare Boolean IsCheckpoint = Anchor.WaypointType == CAnchorData::EWaypointType::Checkpoint;
	if (C_Debug) {
		assert(IsCheckpoint, "Selected landmark is not a checkpoint");
	} else {
		if (!IsCheckpoint) return;
	}

	if (Anchor.Tag == C_AnchorTag_DefaultFlagSpawn) {
		Anchor.Tag = C_AnchorTag_FlagSpawn;
	} else {
		Anchor.Tag = C_AnchorTag_DefaultFlagSpawn;
	}
}

/**
 * Sets the owner of the anchor to the specified Clan.
 * Options for Clan is either '1' or '2'.
 * Can only set the clan for a landmark that can be owned by a clan (Spawn, Base, ...).
 * Does nothing if the landmark cannot be owned by a clan or an invalid clan was provded.
 */
Void Anchor_SetClan(CAnchorData Anchor, Integer Clan) {
	declare Boolean IsClanOwnedLandmark = G_SelectedLandmark.WaypointType == C_WaypointType_Start || G_SelectedLandmark.WaypointType == C_WaypointType_Finish;
	declare Boolean IsValidClan = Clan == 1 || Clan == 2;
	if (C_Debug) {
		assert(IsClanOwnedLandmark, "Selected landmark does not belong to a team");
		assert(IsValidClan, """'{{{ Clan }}}' is not a valid clan""");
	} else {
		if (!IsClanOwnedLandmark || !IsValidClan) return;
	}

	switch (Anchor.WaypointType) {
		case CAnchorData::EWaypointType::Start: Anchor.Tag = C_AnchorTag_Spawn_Prefix ^ Clan;
		case CAnchorData::EWaypointType::Finish: Anchor.Tag = C_AnchorTag_Base_Prefix ^ Clan;
	}
}

/**
 * Sets the selected anchor as an out of bounds trigger.
 * Does not do anythign if the anchor is not suitable for flag reset triggers.
 */
Void Anchor_SetOutOfBoundsTrigger(CAnchorData Anchor) {
	declare Boolean IsCheckpoint = Anchor.WaypointType == CAnchorData::EWaypointType::Checkpoint;
	if (C_Debug) {
		assert(G_SelectedLandmark.WaypointType == C_WaypointType_Checkpoint, "Selected landmark is not a checkpoint");
	} else {
		if (!IsCheckpoint) return;
	}
	Anchor.Tag = C_AnchorTag_OutOfBoundsTrigger;
}

/**
 * Takes the data provided by the UI event and edits the currently selected Landmark.
 */
 Void Anchor_Edit_FromUiEvent(Text[] EditData) {
	declare Boolean ExistingAnchorIsSelected = AnchorData.existskey(G_SelectedLandmark.Id);
	declare Boolean EditCommandExists = EditData.existskey(0);
	if (C_Debug) {
		assert(ExistingAnchorIsSelected, "Landmark to edit does not exist");
		assert(EditCommandExists, "No data provided to edit the landmark");
	} else {
		if (!ExistingAnchorIsSelected || !EditCommandExists) return;
	}

	declare CAnchorData Anchor <=> AnchorData[G_SelectedLandmark.Id];
	declare Text EditCommand = EditData[0];
	// Determined what to edit
	switch (EditCommand) {
		case C_UIEventData_EditLandmark_Team: {
			if (C_Debug) {
				assert(EditData.existskey(1), "No clan provided");
			} else {
				if (!EditData.existskey(1)) return;
			}
			declare Integer Clan = TL::ToInteger(EditData[1]);
			Anchor_SetClan(Anchor, Clan);
		}
		case C_UIEventData_EditLandmark_Function_FlagSpawn: {
			Anchor_SetFlagSpawn(Anchor);
		}
		case C_UIEventData_EditLandmark_Function_DefaultFlagSpawn: {
			Anchor_ToggleDefaultFlagSpawn(Anchor);
		}
		case C_UIEventData_EditLandmark_Function_OutOfBoundsTrigger: {
			Anchor_SetOutOfBoundsTrigger(Anchor);
		}
		case C_UIEventData_EditLandmark_Unused: {
			Anchor_SetUnused(Anchor);
		}
		default: {
			if (C_Debug) {
				assert(False, """Unkown edit command '{{{ EditCommand }}}'""");
			}
		}
	}

	// Update the UI
	SetSelectedAnchor(G_SelectedLandmark.Id);
}

/**
 * Sets the tags of all anchors that are not used by FlagRush to a default value indicating that they are not used.
 */
 Void Anchors_Init() {
	foreach (Anchor in AnchorData) {
		switch (Anchor.WaypointType) {
			case CAnchorData::EWaypointType::Start: {
				if (!TL::StartsWith(C_AnchorTag_Spawn_Prefix, Anchor.Tag)) Anchor_SetUnused(Anchor);
			}
			case CAnchorData::EWaypointType::Finish: {
				if (!TL::StartsWith(C_AnchorTag_Base_Prefix, Anchor.Tag)) Anchor_SetUnused(Anchor);
			}
			case CAnchorData::EWaypointType::Checkpoint: {
				if (!( Anchor.Tag == C_AnchorTag_FlagSpawn || Anchor.Tag == C_AnchorTag_DefaultFlagSpawn || Anchor.Tag == C_AnchorTag_OutOfBoundsTrigger)) Anchor_SetUnused(Anchor);
			}
			default: {
				Anchor_SetUnused(Anchor);
			}
		}
	}
}

Void Team_SetHue(Integer Clan, Real Hue) {
	declare Boolean IsValidClan = Clan == 1 || Clan == 2;
	declare Boolean IsValidHue = Hue == C_TeamHue_Default || (Hue >= 0. && Hue <= 1.);
	if (C_Debug) {
		assert(IsValidClan, """'{{{ Clan }}}' is not a valid clan""");
		assert(IsValidHue, """'{{{ Hue }}}' is not a valid hue""");
	} else {
		if (!IsValidClan || !IsValidHue) return;
	}
	declare metadata Real[Integer] FlagRush_Meta_TeamHues for Map;
	FlagRush_Meta_TeamHues[Clan] = Hue;

	// Update UI
	LayerCustomEvent(G_AnchorPropertiesWindow, C_UIEventType_SetTeamColorHue, [TL::ToText(Clan), TL::ToText(Hue)]);
}

Void PlayTestRun() {
	TMMapType::PlayTestRun_Yield();
	ReportContext::SetContext(System, ReportContext::C_Context_MapEditor);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Main
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
main() {
	HoldLoadingScreen = True;

	// Settings
	ReportContext::SetContext(System, ReportContext::C_Context_MapEditor);
	TMMapType::ApplyDecoImages();
	EnableMapTypeStartTest = True; // The maptype will handle the 'StartTest' event
	CustomEditAnchorData = True;

	// Initialize Map
	MapType::SetVersion(C_MapTypeVersion);
	Anchors_Init();
	UpdateValidability();

	// Initialize layers
	G_Toolbar = UILayerCreate();
	G_Toolbar.ManialinkPage = GetToolbarManialink();
	G_TeamColorsWindow = UILayerCreate();
	G_TeamColorsWindow.ManialinkPage = GetTeamColorWindowManialink();
	G_TeamColorsWindow.IsVisible = False;
	G_AnchorPropertiesWindow = UILayerCreate();
	G_AnchorPropertiesWindow.ManialinkPage = GetEditAnchorManialink();
	G_AnchorPropertiesWindow.IsVisible = False;
	declare metadata Real[Integer] FlagRush_Meta_TeamHues for Map;
	for (Clan, 1, 2) { // Send metadata hues or default values to UI
		LayerCustomEvent(G_TeamColorsWindow, C_UIEventType_SetTeamColorHue, [TL::ToText(Clan), TL::ToText(FlagRush_Meta_TeamHues.get(Clan, C_TeamHue_Default))]);
		LayerCustomEvent(G_AnchorPropertiesWindow, C_UIEventType_SetTeamColorHue, [TL::ToText(Clan), TL::ToText(FlagRush_Meta_TeamHues.get(Clan, C_TeamHue_Default))]);
	}

	HoldLoadingScreen = False;

	while (True) {
		yield;

		// Reset block property window when leaving block property mode
		if (PlaceMode != CMapEditorPlugin::PlaceMode::BlockProperty && G_SelectedLandmark.Id != NullId) {
			SetSelectedAnchor(NullId);
		}

		// Show block property window only if an anchor is edited
		G_AnchorPropertiesWindow.IsVisible = G_SelectedLandmark.Id != NullId;

		// Check Events
		foreach(Event in PendingEvents) {
			switch(Event.Type) {
				case CMapEditorPluginEvent::Type::MapModified: {
					Anchors_Init();
					UpdateValidability();
				}
				case CMapEditorPluginEvent::Type::EditAnchor: {
					SetSelectedAnchor(Event.EditedAnchorDataId);
				}
				case CMapEditorPluginEvent::Type::StartTest: {
					PlayTestRun();
				}
				case CMapEditorPluginEvent::Type::LayerCustomEvent: {
					switch (Event.CustomEventType) {
						case C_UIEventType_ToggleTeamColorsWindow: {
							G_TeamColorsWindow.IsVisible = !G_TeamColorsWindow.IsVisible;
						}
						case C_UIEventType_EditLandmark: {
							Anchor_Edit_FromUiEvent(Event.CustomEventData);
						}
						case C_UIEventType_SetTeamColorHue: {
							if (C_Debug) {
								assert(Event.CustomEventData.existskey(0), "No clan provided");
								assert(Event.CustomEventData.existskey(1), "No hue provided");
							} else {
								if (!Event.CustomEventData.existskey(0) || !Event.CustomEventData.existskey(1)) break;
							}
							declare Integer Clan = TL::ToInteger(Event.CustomEventData[0]);
							declare Real Hue = TL::ToReal(Event.CustomEventData[1]);
							Team_SetHue(Clan, Hue);
						}
					}
				}
			}
		}
	}
}